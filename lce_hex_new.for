      module global
      integer elemoffset, numelem, nintpt
      parameter(elemoffset = 1)
      parameter(numelem = 1)
      parameter(nintpt = 8)
      real*8 globalsdv(numelem,nintpt,30)
      end module
      
      subroutine UVARM(UVAR,DIRECT,T,TIME,DTIME,CMNAME,ORNAME,
     1 NUVARM,NOEL,NPT,LAYER,KSPT,KSTEP,KINC,NDI,NSHR,COORD,
     2 JMAC,JMATYP,MATLAYO,LACCFLA)
      use global
      include 'aba_param.inc'
      
      character*80 cmname, orname
      character*3 flgray(15)
      dimension uvar(nuvarm), direct(3,3), t(3,3), time(2)
      dimension array(15), jarray(15), jmac(*), jmatyp(*), coord(*)
      integer jj
      
      do jj = 1,30
          uvar(jj) = globalsdv(noel-elemoffset,npt,jj)
      end do

      return
      end subroutine
      
      SUBROUTINE UEL(RHS,AMATRX,SVARS,ENERGY,NDOFEL,NRHS,NSVARS,
     +  PROPS,NPROPS,COORDS,MCRD,NNODE,UALL,DUALL,VEL,ACCN,JTYPE,
     + TIME,DTIME,KSTEP,KINC,JELEM,PARAMS,NDLOAD,JDLTYP,ADLMAG,
     +  PREDEF,NPREDF,LFLAGS,MLVARX,DDLMAG,MDLOAD,PNEWDT,JPROPS,
     +  NJPROP,PERIOD)
      use global
      INCLUDE 'ABA_PARAM.INC'
!
! variables defined in uel, passed back to Abaqus
!
      REAL*8 RHS(MLVARX,*),AMATRX(NDOFEL,NDOFEL),SVARS(*),ENERGY(8),
     + PNEWDT
!
! VARIABLES PASSED INTO UEL
!
      REAL*8 PROPS(*),COORDS(MCRD,NNODE),UALL(NDOFEL),DUALL(MLVARX,*),
     +       VEL(NDOFEL),ACCN(NDOFEL),TIME(2),DTIME,PARAMS(*),
     +        ADLMAG(MDLOAD,*),PREDEF(2,NPREDF,NNODE),DDLMAG(MDLOAD,*),
     +        PERIOD

      INTEGER NDOFEL,NRHS,NSVARS,NPROPS,MCRD,NNODE,JTYPE,KSTEP,KINC,
     +              JELEM,NDLOAD,JDLTYP(MDLOAD,*),NPREDF,LFLAGS(*),
     +               MLVARX,MDLOAD,JPROPS(*),NJPROP
!
! VARIABLES DEFINED AND ONLY USED IN UEL
!
      REAL*8 DELTAT, TOL
      REAL*8 XINPT_ALL(3,8), WGHT(8)
      REAL*8 XI(3), NMTX(3,24), BMTX(9,24), JCB
      REAL*8 SVARS_INPT(21), SVARS_INPT_NEW(21), SVARSEL(21,8)
      REAL*8 DEFGRD(3,3), DFGDVEC(9), DPDF(9,9), PK1VEC(9)
      REAL*8 KUU(NDOFEL,NDOFEL), RU(NDOFEL), ATEM(NDOFEL,NDOFEL)
      REAL*8 RHSTEM(24), TEM9(9), TEM3(3), TEM33(3,3)
      REAL*8 FTEM(3,3), FVTEM(3,3), SIGTEM(3,3), PKTEM(3,3), DIRTEM(3)
      REAL*8 FNTEM(3,3), FVNTEM(3,3), DIRNTEM(3)
      REAL*8 PSI_DOT_INPT, PSI_DOT, DINT_INPT, LVD, DIRDSP, DIRDSP_INPT
      REAL*8 STRESS_POWER, SP_INPT
      INTEGER NSOLVE, I, JJ
      
      DELTAT = DTIME
      TOL = 1E-10
      NSOLVE = 200    

! SET UP LOCAL COORDINATES  AND WEIGHTS OF INTEGRATION POINTS
      CALL CAL_INTPT_HEX8(XINPT_ALL, WGHT)

! INITIALIZE AMATRX AND RHS
      KUU = 0.
      RU = 0.
      TEM9 = 0.
      TEM9(1) = 1.
      TEM9(2) = 1.
      TEM9(3) = 1.
      SVARS_INPT = 0.
      SVARSEL = 0.
      LVD = 0.
      PSI = 0.
      PSI_DOT = 0.
      DIRDSP = 0.
      STRESS_POWER = 0.

! INITIALIZE IF IT IS THE FIRST STEP AND FIRST INCREMENT
      IF ((KINC .LE. 1) .AND. (KSTEP .EQ. 1)) THEN
           SVARS_INPT(1:9) = TEM9
           SVARS_INPT(10) = PROPS(8)
           SVARS_INPT(11) = PROPS(9)
           SVARS_INPT(12) = PROPS(10)
           SVARS_INPT(13:21) = TEM9
      DO I = 1,8
          SVARSEL(:,I) = SVARS_INPT
      END DO
      ELSE
! OBTAIN LAST STEP NUMBER AND INCREMENT NUMBER
      DO I = 1,8
          DO JJ = 1,21
                SVARSEL(JJ,I) = SVARS(21*(I-1)+JJ)
	    END DO
      END DO
      ENDIF

! LOOP OVER ALL INTEGRATION POINTS
      DO I = 1,8
! GET LOCAL COORD AND SDV PER INTPT.
           XI(1) = XINPT_ALL(1,I)
           XI(2) = XINPT_ALL(2,I)
           XI(3) = XINPT_ALL(3,I)
           SVARS_INPT = SVARSEL(:,I)
           
! CALCULATE F
           CALL CAL_SHP_HEX8(XI, COORDS, NMTX, BMTX, JCB)
           CALL MATVEC(BMTX, UALL, 9, 24, DFGDVEC)
           CALL VECTOR2MATRIX(DFGDVEC, DEFGRD)
           DEFGRD(1,1) = DEFGRD(1,1) + 1.
           DEFGRD(2,2) = DEFGRD(2,2) + 1.
           DEFGRD(3,3) = DEFGRD(3,3) + 1.

! DO MATERIAL UPDATE
          CALL MATERIALTANGENT(DEFGRD, SVARS_INPT, PROPS,
     +         NSOLVE, DELTAT, TOL, DPDF, PK1VEC, SVARS_INPT_NEW)
          
! TEMPORARY VARIABLES TO DO ENERGY OUTPUT
! STATE VARIABLSE
          FTEM = DEFGRD
          DIRTEM = SVARS_INPT_NEW(10:12)
          TEM9 = SVARS_INPT_NEW(13:21)
          CALL VECTOR2MATRIX(TEM9, FVTEM)
          
          TEM9 = SVARS_INPT(1:9)
          CALL VECTOR2MATRIX(TEM9, FNTEM)
          DIRNTEM = SVARS_INPT(10:12)
          TEM9 = SVARS_INPT(13:21)
          CALL VECTOR2MATRIX(TEM9, FVNTEM)
          
! ENERGY
          CALL FREE_ENERGY(PROPS, FTEM, FVTEM, DIRTEM, PSI_INPT)
          CALL CAL_DINT(PROPS, FNTEM, FVNTEM, DIRNTEM, FTEM,
     +                    FVTEM, DIRTEM, DELTAT, DINT_INPT)
          CALL CAL_PSI_DOT3(PROPS, FNTEM, FVNTEM, DIRNTEM, FTEM,
     +             FVTEM, DIRTEM, DELTAT, PSI_DOT_INPT)
          CALL CAL_DIR_DISSIPATION(PROPS, FNTEM, FVNTEM, DIRNTEM, 
     +           FTEM, FVTEM, DIRTEM, DELTAT, DIRDSP_INPT)
          CALL CAL_STRESS_POWER(PROPS, FNTEM, FVNTEM, DIRNTEM, 
     +             FTEM, FVTEM, DIRTEM, DELTAT, SP_INPT)
          
          
! UPDATE SVARS AND PASS TO DUMMY ELEMENT
          DO JJ = 1,21
          SVARS(21*(I-1)+JJ) =  SVARS_INPT_NEW(JJ)
          GLOBALSDV(JELEM, I, JJ) = SVARS_INPT_NEW(JJ)
          END DO
      
          DO JJ = 1,9
              GLOBALSDV(JELEM,I,21+JJ) = PK1VEC(JJ)
          END DO

! CALCULATE CONTRIBUTION TO AMATRX AND RHS
          ATEM = MATMUL(TRANSPOSE(BMTX),MATMUL(DPDF,BMTX))*JCB*WGHT(I)
          CALL MATVEC(TRANSPOSE(BMTX), PK1VEC, 24, 9, RHSTEM)
          
          RHSTEM = RHSTEM*JCB*WGHT(I)
          KUU = KUU + ATEM
          ru = ru - rhstem
          
          LVD = LVD + DINT_INPT*JCB*WGHT(I)
          PSI = PSI + PSI_INPT*JCB*WGHT(I)
          STRESS_POWER = STRESS_POWER + SP_INPT*JCB*WGHT(I)
          PSI_DOT = PSI_DOT + PSI_DOT_INPT*JCB*WGHT(I)
          DIRDSP = DIRDSP + DIRDSP_INPT*JCB*WGHT(I)
          
      END DO

! TOTAL AMATRX AND RHS
      AMATRX = KUU
      DO I = 1,NDOFEL
          RHS(I,1) = RU(I)
      END DO
      
! ENERGY OUTPUT
      ENERGY(1) = PSI
      ENERGY(2) = STRESS_POWER
      ENERGY(3) = PSI_DOT
      ENERGY(4) = LVD
      ENERGY(5) = DIRDSP
      
      
      RETURN
      END SUBROUTINE
      
      SUBROUTINE CAL_SHP_HEX8(XINPT, COORD, NMTX, BMTX, JCB)
  ! CALCULATE SHAPE FUNCTIONS AND DERIVATIVES GIVEN XI AND COORDS
  ! XINPT(3)        LOCAL COORD OF INTEGRATION POINT
  ! COORD(3,8)      GLOBAL COORD OF 8-NODE
  ! SHP(8)          FUNCTION VALUE OF 8 SHAPE FUNCTIONS OF GIVEN INTEGRATION POINT
  ! DNDX(8,3)       FUNCTION VALUE OF GLOBAL DERIVATIVE OF SHP. OF GIVEN INPT.
  ! DNDXI(8,3)      FUNCTION VALUE OF LOCAL DERIVATIVE OF SHP. OF GIVEN INPT.

  ! DXDXI(3,3)      DERIVATIVES GLOBAL TO LOCAL
  ! DXIDX(3,3)      DERIVATIVES LOCAL TO GLOBAL
  ! JCB             DETERIMINANT OF DXDXI
  ! XIO(8,3)        LOCAL COORD OF 8 NODE
      IMPLICIT NONE
      REAL*8 XINPT(3), COORD(3,8), NMTX(3,24), BMTX(9,24), JCB
      REAL*8 SHP(8), DNDX(8,3), DNDXI(8,3), DXDXI(3,3), DXIDX(3,3)
      REAL*8 XIO(8,3), XI, ETA, ZETA, NX, NY, NZ
      INTEGER I

! GIVEN XIO
      XIO(1,:) = [-1., -1., -1.]
      XIO(2,:) = [ 1., -1., -1.]
      XIO(3,:) = [ 1.,  1., -1.]
      XIO(4,:) = [-1.,  1., -1.]
      XIO(5,:) = [-1., -1.,  1.]
      XIO(6,:) = [ 1., -1.,  1.]
      XIO(7,:) = [ 1.,  1.,  1.]
      XIO(8,:) = [-1.,  1.,  1.]

      XI = XINPT(1)
      ETA = XINPT(2)
      ZETA = XINPT(3)
      DO I = 1,8
        SHP(I) = (1+XIO(I,1)*XI)*(1+XIO(I,2)*ETA)*(1+XIO(I,3)*ZETA)/8.
      END DO

! DERIVATIVE TO XI
      DNDXI(1,1) = -((ETA - 1)*(ZETA - 1))/8.
      DNDXI(2,1) = ((ETA - 1)*(ZETA - 1))/8.
      DNDXI(3,1) = -((ETA + 1)*(ZETA - 1))/8.
      DNDXI(4,1) = ((ETA + 1)*(ZETA - 1))/8.
      DNDXI(5,1) = ((ETA - 1)*(ZETA + 1))/8.
      DNDXI(6,1) = -((ETA - 1)*(ZETA + 1))/8.
      DNDXI(7,1) = ((ETA + 1)*(ZETA + 1))/8.
      DNDXI(8,1) = -((ETA + 1)*(ZETA + 1))/8.

! DERIVATIVE TO ETA
      DNDXI(1,2) = -((XI - 1)*(ZETA - 1))/8.
      DNDXI(2,2) = ((XI + 1)*(ZETA - 1))/8.
      DNDXI(3,2) = -((XI + 1)*(ZETA - 1))/8.
      DNDXI(4,2) = ((XI - 1)*(ZETA - 1))/8.
      DNDXI(5,2) = ((XI - 1)*(ZETA + 1))/8.
      DNDXI(6,2) = -((XI + 1)*(ZETA + 1))/8.
      DNDXI(7,2) = ((XI + 1)*(ZETA + 1))/8.
      DNDXI(8,2) = -((XI - 1)*(ZETA + 1))/8.

! DERIVATIVE TO ZETA
      DNDXI(1,3)=-((ETA - 1)*(XI - 1))/8.
      DNDXI(2,3)=((ETA - 1)*(XI + 1))/8.
      DNDXI(3,3)=-((ETA + 1)*(XI + 1))/8.
      DNDXI(4,3)=((ETA + 1)*(XI - 1))/8.
      DNDXI(5,3)=((ETA - 1)*(XI - 1))/8.
      DNDXI(6,3)=-((ETA - 1)*(XI + 1))/8.
      DNDXI(7,3)=((ETA + 1)*(XI + 1))/8.
      DNDXI(8,3)=-((ETA + 1)*(XI - 1))/8.

! DXDXI
      DXDXI(1,1) = DOT_PRODUCT(COORD(1,:),DNDXI(:,1))
      DXDXI(1,2) = DOT_PRODUCT(COORD(1,:),DNDXI(:,2))
      DXDXI(1,3) = DOT_PRODUCT(COORD(1,:),DNDXI(:,3))
      DXDXI(2,1) = DOT_PRODUCT(COORD(2,:),DNDXI(:,1))
      DXDXI(2,2) = DOT_PRODUCT(COORD(2,:),DNDXI(:,2))
      DXDXI(2,3) = DOT_PRODUCT(COORD(2,:),DNDXI(:,3))
      DXDXI(3,1) = DOT_PRODUCT(COORD(3,:),DNDXI(:,1))
      DXDXI(3,2) = DOT_PRODUCT(COORD(3,:),DNDXI(:,2))
      DXDXI(3,3) = DOT_PRODUCT(COORD(3,:),DNDXI(:,3))

      CALL DET(DXDXI, JCB)
      CALL MATINV3D(DXDXI, DXIDX)

      DO I = 1,8
        DNDX(I,1) = DNDXI(I,1)*DXIDX(1,1)+DNDXI(I,2)*DXIDX(2,1)+
     +               DNDXI(I,3)*DXIDX(3,1)
        DNDX(I,2) = DNDXI(I,1)*DXIDX(1,2)+DNDXI(I,2)*DXIDX(2,2)+
     +               DNDXI(I,3)*DXIDX(3,2)
        DNDX(I,3) = DNDXI(I,1)*DXIDX(1,3)+DNDXI(I,2)*DXIDX(2,3)+
     +               DNDXI(I,3)*DXIDX(3,3)
      END DO

! CALCULATE NMTX AND MTX
      DO I = 1,8
        NMTX(1,1+3*(I-1)) = SHP(I)
        NMTX(2,2+3*(I-1)) = SHP(I)
        NMTX(3,3+3*(I-1)) = SHP(I)
        NMTX(1,2+3*(I-1)) = 0.
        NMTX(1,3+3*(I-1)) = 0.
        NMTX(2,1+3*(I-1)) = 0.
        NMTX(2,3+3*(I-1)) = 0.
        NMTX(3,1+3*(I-1)) = 0.
        NMTX(3,2+3*(I-1)) = 0.

        NX = DNDX(I,1)
        NY = DNDX(I,2)
        NZ = DNDX(I,3)

        BMTX(1,1+3*(I-1)) = NX
        BMTX(1,2+3*(I-1)) = 0.
        BMTX(1,3+3*(I-1)) = 0.

        BMTX(2,1+3*(I-1)) = 0.
        BMTX(2,2+3*(I-1)) = NY
        BMTX(2,3+3*(I-1)) = 0.

        BMTX(3,1+3*(I-1)) = 0.
        BMTX(3,2+3*(I-1)) = 0.
        BMTX(3,3+3*(I-1)) = NZ

        BMTX(4,1+3*(I-1)) = 0.
        BMTX(4,2+3*(I-1)) = NZ
        BMTX(4,3+3*(I-1)) = 0.

        BMTX(5,1+3*(I-1)) = NZ
        BMTX(5,2+3*(I-1)) = 0.
        BMTX(5,3+3*(I-1)) = 0.

        BMTX(6,1+3*(I-1)) = NY
        BMTX(6,2+3*(I-1)) = 0.
        BMTX(6,3+3*(I-1)) = 0.

        BMTX(7,1+3*(I-1)) = 0.
        BMTX(7,2+3*(I-1)) = NX
        BMTX(7,3+3*(I-1)) = 0.

        BMTX(8,1+3*(I-1)) = 0.
        BMTX(8,2+3*(I-1)) = 0.
        BMTX(8,3+3*(I-1)) = NX

        BMTX(9,1+3*(I-1)) = 0.
        BMTX(9,2+3*(I-1)) = 0.
        BMTX(9,3+3*(I-1)) = NY
      END DO

      RETURN
      END SUBROUTINE
      
      SUBROUTINE CAL_INTPT_HEX8(XINPT_ALL, WGHT)
      IMPLICIT NONE
      REAL*8 XINPT_ALL(3, 8), WGHT(8)
      
      XINPT_ALL(1,:) = [-1.,  1.,  1., -1., -1.,  1., 1., -1.]
      XINPT_ALL(2,:) = [-1., -1.,  1.,  1., -1., -1., 1.,  1.]
      XINPT_ALL(3,:) = [-1., -1., -1., -1.,  1.,  1., 1.,  1.]

      XINPT_ALL = 0.5774*XINPT_ALL
      WGHT = [1., 1., 1., 1., 1., 1., 1., 1.]

      RETURN
      END SUBROUTINE
      
      SUBROUTINE MATERIALTANGENT(DEFGRD, SVARS_INPT, 
     + PROPS, NSOLVE, DELTAT, TOL, DPDF, PK1VEC,svars_inpt_new)
! CALCULATE MATERIAL TANGENT DPDF WITH GIVEN INTEGRATION POINT
! XINPT           LOCAL COORD OF GIVEN INTEGRATION POINT
! COORD           GLOBAL COORD OF 8 NODE
! DISP_VEC        NODE DISP
! SVARS_INPT      42 STATE VARIABLES OF GIVEN INTEGRATION POINT
! PROPS           MATERIAL PROPERTIES
! NSOLVE          MAXIMAL ITERATION NUMBER
! DELTAT          TIME INCREMENT
! TOL             TOLERANCE
! DPDF            MATERIAL TANGENT
      IMPLICIT NONE
      REAL*8 SVARS_INPT(21), 
     + PROPS(12), DELTAT, TOL, DPDF(9,9),svars_inpt_new(21)
      REAL*8 DEFGRD_N(3,3), DEFGRDV_N(3,3), DIR_N(3), DEFGRD(3,3), 
     + DEFGRDV_ITER(3,3), DIR_ITER(3)
      REAL*8 TEM3(3), TEM9(9), TEM33(3,3), RESQ(12), SVARSQ(12), 
     + RQ, QINCRT(12), KSVARS(12,12), PK1VEC(9)
      INTEGER INNERITER, NSOLVE, I, J

! ASSIGN VALUES FOR STATE VARIABLES
      TEM9 = SVARS_INPT(1:9)
      CALL VECTOR2MATRIX(TEM9, DEFGRD_N)
      DIR_N(1) = SVARS_INPT(10)
      DIR_N(2) = SVARS_INPT(11)
      DIR_N(3) = SVARS_INPT(12)
      TEM9 = SVARS_INPT(13:21)
      CALL VECTOR2MATRIX(TEM9, DEFGRDV_N)

      DIR_ITER = DIR_N
      DEFGRDV_ITER = DEFGRDV_N

      RQ = 1.
      SVARSQ = SVARS_INPT(10:21)

      DO INNERITER = 1,NSOLVE
      CALL RESDIR(PROPS, DEFGRD_N, DEFGRDV_N, DIR_N, DEFGRD, 
     + DEFGRDV_ITER, DIR_ITER, DELTAT, TEM3)
      CALL RESDEFGRDV(PROPS, DEFGRDV_N, DEFGRD, DEFGRDV_ITER, 
     + DIR_ITER, DELTAT, TEM33)
      CALL TANGENT_SVARS(PROPS, DEFGRD_N, DEFGRDV_N, DIR_N, DEFGRD, 
     + DEFGRDV_ITER, DIR_ITER, DELTAT, KSVARS)

      RESQ(1) = TEM3(1)
      RESQ(2) = TEM3(2)
      RESQ(3) = TEM3(3)
      RESQ(4) = TEM33(1,1)
      RESQ(5) = TEM33(2,2)
      RESQ(6) = TEM33(3,3)
      RESQ(7) = TEM33(2,3)
      RESQ(8) = TEM33(1,3)
      RESQ(9) = TEM33(1,2)
      RESQ(10) = TEM33(2,1)
      RESQ(11) = TEM33(3,1)
      RESQ(12) = TEM33(3,2)

      CALL MATINVVEC(KSVARS, RESQ, 12, QINCRT)
      QINCRT = - QINCRT
      SVARSQ = SVARSQ + QINCRT

      DIR_ITER(1) = SVARSQ(1)
      DIR_ITER(2) = SVARSQ(2)
      DIR_ITER(3) = SVARSQ(3)
      DEFGRDV_ITER(1,1) = SVARSQ(4)
      DEFGRDV_ITER(2,2) = SVARSQ(5)
      DEFGRDV_ITER(3,3) = SVARSQ(6)
      DEFGRDV_ITER(2,3) = SVARSQ(7)
      DEFGRDV_ITER(1,3) = SVARSQ(8)
      DEFGRDV_ITER(1,2) = SVARSQ(9)
      DEFGRDV_ITER(2,1) = SVARSQ(10)
      DEFGRDV_ITER(3,1) = SVARSQ(11)
      DEFGRDV_ITER(3,2) = SVARSQ(12)

      RQ = SQRT(DOT_PRODUCT(RESQ,RESQ))
      IF (RQ .LT. TOL) THEN
!        PRINT *, 'EXIT AT INNERSTEP', INNERITER
      EXIT
      END IF
      END DO

! UPDATE STATE VARIABLES
      CALL MATRIX2VECTOR(DEFGRD, TEM9)
      SVARS_INPT_new(1:9) = TEM9
      SVARS_INPT_new(10:21) = SVARSQ

! CALCULATE TOTAL STIFFNESS MATRIX
      CALL TANGENT_STRESS(PROPS, DEFGRD_N, DEFGRDV_N, DIR_N, DEFGRD, 
     + DEFGRDV_ITER, DIR_ITER, DELTAT, DPDF)
      CALL PK1(PROPS, DEFGRD, DEFGRDV_ITER, DIR_ITER, TEM33)
      CALL MATRIX2VECTOR(TEM33, PK1VEC)
      
      RETURN
      END SUBROUTINE
      
            
      SUBROUTINE TENSOR2MATRIX12(A,K)
! CONVERT A 3TH ORDER TENSOR TO 3-BY-9 MATRIX
      IMPLICIT NONE
      REAL*8 A(3,3,3), K(3,9)
      INTEGER I,J, INDI(9,2)
      INDI(:,1) = [1, 2, 3, 2, 1, 1, 2, 3, 3]
      INDI(:,2) = [1, 2, 3, 3, 3, 2, 1, 1, 2]
      DO I = 1,3
        DO J = 1,9
          K(I,J) = A(I,INDI(J,1),INDI(J,2))
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE TENSOR2MATRIX21(A,K)
! CONVERT A 3TH ORDER TENSOR TO 9-BY-3 MATRIX
      IMPLICIT NONE
      REAL*8 A(3,3,3), K(9,3)
      INTEGER I,J, INDI(9,2)
      INDI(:,1) = [1, 2, 3, 2, 1, 1, 2, 3, 3]
      INDI(:,2) = [1, 2, 3, 3, 3, 2, 1, 1, 2]
      DO I = 1,9
        DO J = 1,3
          K(I,J) = A(INDI(I,1),INDI(I,2),J)
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE TENSOR2MATRIX22(A,K)
! CONVERT A 4TH ORDER TENSOR TO 9-BY-9 MATRIX
      IMPLICIT NONE
      REAL*8 A(3,3,3,3), K(9,9)
      INTEGER I,J, INDI(9,2)
      INDI(:,1) = [1, 2, 3, 2, 1, 1, 2, 3, 3]
      INDI(:,2) = [1, 2, 3, 3, 3, 2, 1, 1, 2]
      DO I = 1,9
        DO J = 1,9
          K(I,J) = A(INDI(I,1),INDI(I,2),INDI(J,1),INDI(J,2))
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE VECTOR2MATRIX(X, A)
! CONVERT VECTOR X TO MATRIX A WITH VOGIT
      IMPLICIT NONE
      REAL*8 A(3,3), X(9)
      A(1,1) = X(1)
      A(2,2) = X(2)
      A(3,3) = X(3)
      A(2,3) = X(4)
      A(1,3) = X(5)
      A(1,2) = X(6)
      A(2,1) = X(7)
      A(3,1) = X(8)
      A(3,2) = X(9)
      RETURN
      END SUBROUTINE

      SUBROUTINE MATRIX2VECTOR(A, X)
! CONVERT MATRIX A TO VECTOR X WITH VOGIT
      IMPLICIT NONE
      REAL*8 A(3,3), X(9)
      X(1) = A(1,1)
      X(2) = A(2,2)
      X(3) = A(3,3)
      X(4) = A(2,3)
      X(5) = A(1,3)
      X(6) = A(1,2)
      X(7) = A(2,1)
      X(8) = A(3,1)
      X(9) = A(3,2)
      RETURN
      END SUBROUTINE

      SUBROUTINE MATVEC(A, D, N1, N2, AD)
! CALCULATE PRODUCT OF MATRIX A AND VECTOR D, AD = A*D
! N1: ROW
! N2: COLUMN
      IMPLICIT NONE
      INTEGER N1, N2, I, J
      REAL*8 A(N1,N2), D(N2), AD(N1)

      DO I = 1,N1
        AD(I) = 0.
      END DO

      DO I = 1,N1
        DO J = 1,N2
          AD(I) = AD(I) + A(I,J)*D(J)
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE MATINVVEC(A, D, N, AD)
! CALCULATE PRODUCT OF MATRIX A AND VECTOR D, AD = inv(A)*D
      IMPLICIT NONE
      INTEGER N, I, J
      REAL*8 A(N,N), AINV(N,N), D(N), AD(N)

      DO I = 1,N
        AD(I) = 0.
      END DO

      CALL MATINVMD(A, N, AINV)

      DO I = 1,N
        DO J = 1,N
          AD(I) = AD(I) + AINV(I,J)*D(J)
        END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE DDOT(A, B, AB)
! CALCULATE THE DOUBLE DOT PRODUCT OF TWO 3-BY-3 MATRIX
      IMPLICIT NONE
      REAL*8 A(3,3), B(3,3)
      REAL*8 AB
      AB =   A(1,1)*B(1,1) + A(1,2)*B(1,2) + A(1,3)*B(1,3)
     +     + A(2,1)*B(2,1) + A(2,2)*B(2,2) + A(2,3)*B(2,3)
     +     + A(3,1)*B(3,1) + A(3,2)*B(3,2) + A(3,3)*B(3,3)
      RETURN
      END SUBROUTINE

      SUBROUTINE MATINVMD(A, N, AINV)

      IMPLICIT NONE
      INTEGER I, J, N, K, M, L
      REAL*8 A(N,N),AINV(N,N), AEXTEND(N,2*N), ROWTEM(2*N), MELIST(N)
      REAL*8 T, MAXIMUM

      DO I = 1,N
        DO J = 1,N
        AEXTEND(I,J) = A(I,J)
        IF  (I .EQ. J) THEN
            AEXTEND(I,J+N) = 1.
        ELSE
            AEXTEND(I,J+N) = 0.
        END IF
        END DO
      END DO

        DO K = 1,N

          MELIST = ABS(AEXTEND(:,K))
          MAXIMUM = MELIST(K)
          M = K
          DO L = K+1,N
            IF (MELIST(L) .GT. MAXIMUM) THEN
              M = L
              MAXIMUM = MELIST(L)
            END IF
          END DO

          ROWTEM = AEXTEND(K,:)
          AEXTEND(K,:) = AEXTEND(M,:)
          AEXTEND(M,:) = ROWTEM

          DO I = 1,N
            IF (I .NE. K) THEN
              T = AEXTEND(I,K)/AEXTEND(K,K)
              AEXTEND(I,:) = AEXTEND(I,:)-T*AEXTEND(K,:)
            END IF
          END DO
          AEXTEND(K,:) = AEXTEND(K,:)/AEXTEND(K,K)

        END DO

        DO I = 1,N
          DO J = 1,N
            AINV(I,J) = AEXTEND(I,J+N)
          END DO
        END DO
        RETURN
        END SUBROUTINE

        SUBROUTINE MATINV3D(A,A_INV)
!
! RETURNS A_INV, THE INVERSE AND DET_A, THE DETERMINANT
! NOTE THAT THE DET IS OF THE ORIGINAL MATRIX, NOT THE
! INVERSE
!
        IMPLICIT NONE
        !
        INTEGER ISTAT
        !
        REAL*8 A(3,3),A_INV(3,3),DET_A,DET_A_INV


        ISTAT = 1

        DET_A = A(1,1)*(A(2,2)*A(3,3) - A(3,2)*A(2,3)) -
     +          A(2,1)*(A(1,2)*A(3,3) - A(3,2)*A(1,3)) +
     +           A(3,1)*(A(1,2)*A(2,3) - A(2,2)*A(1,3))

        IF (DET_A .LE. 0.D0) THEN
c          WRITE(*,*) 'WARNING: SUBROUTINE MATINV3D:'
c          WRITE(*,*) 'WARNING: DET OF MAT=',DET_A
          ISTAT = 0
          RETURN
        END IF

        DET_A_INV = 1.D0/DET_A

        A_INV(1,1) = DET_A_INV*(A(2,2)*A(3,3)-A(3,2)*A(2,3))
        A_INV(1,2) = DET_A_INV*(A(3,2)*A(1,3)-A(1,2)*A(3,3))
        A_INV(1,3) = DET_A_INV*(A(1,2)*A(2,3)-A(2,2)*A(1,3))
        A_INV(2,1) = DET_A_INV*(A(3,1)*A(2,3)-A(2,1)*A(3,3))
        A_INV(2,2) = DET_A_INV*(A(1,1)*A(3,3)-A(3,1)*A(1,3))
        A_INV(2,3) = DET_A_INV*(A(2,1)*A(1,3)-A(1,1)*A(2,3))
        A_INV(3,1) = DET_A_INV*(A(2,1)*A(3,2)-A(3,1)*A(2,2))
        A_INV(3,2) = DET_A_INV*(A(3,1)*A(1,2)-A(1,1)*A(3,2))
        A_INV(3,3) = DET_A_INV*(A(1,1)*A(2,2)-A(2,1)*A(1,2))


        RETURN
        END SUBROUTINE MATINV3D

        SUBROUTINE MATINV2D(A,A_INV)
C CALCULATE INVERSE OF 2-BY-2 MATRIX A
        IMPLICIT NONE
        REAL*8 A(2,2), A_INV(2,2), J
        
        CALL DET2D(A,J)
        A_INV(1,1) = A(2,2)/J
        A_INV(1,2) = -A(1,2)/J
        A_INV(2,1) = -A(2,1)/J
        A_INV(2,2) = A(1,1)/J
        
        RETURN
        END SUBROUTINE

      SUBROUTINE DET(A, J)
! CALCULATE THE DETERMINANT OF A 3-BY-3 MATRIX A AND RETURN J
        IMPLICIT NONE
        REAL*8 A(3,3)
        REAL*8 J
        J = A(1,1)*A(2,2)*A(3,3)
     +          + A(1,2)*A(2,3)*A(3,1)
     +           + A(1,3)*A(2,1)*A(3,2)
     +           - A(3,1)*A(2,2)*A(1,3)
     +           - A(3,2)*A(2,3)*A(1,1)
     +           - A(3,3)*A(2,1)*A(1,2)
        RETURN
      END SUBROUTINE DET

        SUBROUTINE DET2D(A, J)
! CALCULATE THE DETERMINANT OF A 2-BY-2 MATRIX A AND RETURN J
        IMPLICIT NONE
        REAL*8 A(2,2)
        REAL*8 J
        J = A(1,1)*A(2,2)-A(1,2)*A(2,1)
        RETURN
        END SUBROUTINE DET2D

      SUBROUTINE IDGENERATION(KCRON)
! GENERATE AN IDENTITY MATRIX
        IMPLICIT NONE
        REAL*8 KCRON(3,3)
        KCRON(1,1) = 1.
        KCRON(1,2) = 0.
        KCRON(1,3) = 0.
        KCRON(2,1) = 0.
        KCRON(2,2) = 1.
        KCRON(2,3) = 0.
        KCRON(3,1) = 0.
        KCRON(3,2) = 0.
        KCRON(3,3) = 1.
        RETURN
      END SUBROUTINE

      SUBROUTINE FETAD(PROPS, SIGMA, ETAD_OUTPUT)
!   CALCULATE THE BULK VISCOSITY BY MATERIAL PEOPERTY AND STRESS
        IMPLICIT NONE
        REAL*8 PROPS(12)
        REAL*8 SIGMA(3,3)
        REAL*8 ETAD_OUTPUT, TEM, STRCOE, ETAD0

        STRCOE = PROPS(7)
        ETAD0 = PROPS(5)
        CALL DDOT(SIGMA, SIGMA, TEM)
        ETAD_OUTPUT = ETAD0*EXP(-SQRT(TEM) / STRCOE)
        RETURN
        END SUBROUTINE FETAD

        SUBROUTINE SIGMA(PROPS, DEFGRD, DEFGRDV, DIR, STRESS_OUTPUT)
! CALCULATE REAL STRESS SIGMA/J
        IMPLICIT NONE
        REAL*8 PROPS(12), DEFGRD(3,3), DEFGRDV(3,3), DIR(3)
        REAL*8 STRESS_OUTPUT(3,3), JCB, SIG_BAR(3,3)
        
        CALL SIGMA_BAR(PROPS, DEFGRD, DEFGRDV, DIR, SIG_BAR)
        CALL DET(DEFGRD, JCB)
        
        STRESS_OUTPUT = SIG_BAR/JCB
        
        RETURN
        END SUBROUTINE SIGMA

      SUBROUTINE SIGMA_BAR(PROPS, DEFGRD, DEFGRDV, DIR, STRESS_OUTPUT)
! CALCLUCLATE CAUCHY STRESS
! VARIABLES DECLARATION
        IMPLICIT NONE
        REAL*8 DIR(3), PROPS(12), DEFGRD(3,3), DEFGRDV(3,3), 
     +         DEFGRDE(3,3), STRESS_OUTPUT(3,3)
        REAL*8 SHATEN(3,3), SHATEN0(3,3), ELAB(3,3), ELABE(3,3), 
     +         ELABD(3), ELABED(3)
        REAL*8 DEFGRDV_INV(3,3), SHATEN_INV(3,3)
        REAL*8 PRESSURE, ELAI, ELAIE, JCB
        REAL*8 ORDPARA, LOCKLIM, MUEQ, MUNEQ, BULKPENALTY
        REAL*8 SIGMAEQ(3,3), SIGMANEQ(3,3)
        REAL*8 SEQ_TEM, SNEQ_TEM

! ASSIGN VALUES FOR MATERIAL PARAMETERS
      ORDPARA = PROPS(1)
      LOCKLIM = PROPS(2)
      MUEQ = PROPS(3)
      MUNEQ = PROPS(4)
      BULKPENALTY = PROPS(11)

! CALCULATE RELATIVE VARIABLES IN SOFT-ELASTICITY
        CALL  CAL_SHAPETENSOR(PROPS, DIR, SHATEN, SHATEN0)
        CALL  CAL_ELAB(PROPS, DEFGRD, DEFGRDV, DIR, ELAB, ELABE)
        CALL  CAL_ELAI(PROPS, DEFGRD, DEFGRDV, DIR, ELAI, ELAIE)

! CALCULATE PRESSURE
        CALL DET(DEFGRD, JCB)
        PRESSURE = MUEQ - BULKPENALTY*(JCB-1.)
c        PRESSURE = MUEQ - BULKPENALTY*(JCB - 1./JCB)

! CALCULATE TWO COMPONENTS OF STRESS SIGMA_EQ AND SIGMA_NEQ
      SEQ_TEM = MUEQ/(1.-ORDPARA)*LOCKLIM/(LOCKLIM - (ELAI - 3.))
      SNEQ_TEM = MUNEQ/(1.-ORDPARA)*LOCKLIM/(LOCKLIM - (ELAIE - 3.))

      CALL MATVEC(ELAB, DIR, 3, 3, ELABD)
      CALL MATVEC(ELABE, DIR, 3, 3, ELABED)

      SIGMAEQ(1,1) = SEQ_TEM*(ELAB(1,1)- 3.*ORDPARA/2./(1.+2.*ORDPARA)*
     +            (DIR(1)*ELABD(1) + DIR(1)*ELABD(1))) - PRESSURE
      SIGMAEQ(2,2) = SEQ_TEM*(ELAB(2,2)- 3.*ORDPARA/2./(1.+2.*ORDPARA)*
     +            (DIR(2)*ELABD(2) + DIR(2)*ELABD(2))) - PRESSURE
      SIGMAEQ(3,3) = SEQ_TEM*(ELAB(3,3)- 3.*ORDPARA/2./(1.+2.*ORDPARA)*
     +            (DIR(3)*ELABD(3) + DIR(3)*ELABD(3))) - PRESSURE
      SIGMAEQ(1,2) = SEQ_TEM*(ELAB(1,2)- 3.*ORDPARA/2./(1.+2.*ORDPARA)*
     +            (DIR(1)*ELABD(2) + DIR(2)*ELABD(1)))
      SIGMAEQ(1,3) = SEQ_TEM*(ELAB(1,3)- 3.*ORDPARA/2./(1.+2.*ORDPARA)*
     +            (DIR(1)*ELABD(3) + DIR(3)*ELABD(1)))
      SIGMAEQ(2,3) = SEQ_TEM*(ELAB(2,3)- 3.*ORDPARA/2./(1.+2.*ORDPARA)*
     +            (DIR(2)*ELABD(3) + DIR(3)*ELABD(2)))
      SIGMAEQ(2,1) = SIGMAEQ(1,2)
      SIGMAEQ(3,1) = SIGMAEQ(1,3)
      SIGMAEQ(3,2) = SIGMAEQ(2,3)

      SIGMANEQ(1,1) = SNEQ_TEM*(ELABE(1,1)- 3.*ORDPARA/2./
     +    (1.+2.*ORDPARA)*(DIR(1)*ELABED(1) + DIR(1)*ELABED(1))) - MUNEQ
      SIGMANEQ(2,2) = SNEQ_TEM*(ELABE(2,2)- 3.*ORDPARA/2./
     +    (1.+2.*ORDPARA)*(DIR(2)*ELABED(2) + DIR(2)*ELABED(2))) - MUNEQ
      SIGMANEQ(3,3) = SNEQ_TEM*(ELABE(3,3)- 3.*ORDPARA/2./
     +    (1.+2.*ORDPARA)*(DIR(3)*ELABED(3) + DIR(3)*ELABED(3))) - MUNEQ
      SIGMANEQ(1,2) = SNEQ_TEM*(ELABE(1,2)- 3.*ORDPARA/2./
     +    (1.+2.*ORDPARA)*(DIR(1)*ELABED(2) + DIR(2)*ELABED(1)))
      SIGMANEQ(1,3) = SNEQ_TEM*(ELABE(1,3)- 3.*ORDPARA/2./
     +    (1.+2.*ORDPARA)*(DIR(1)*ELABED(3) + DIR(3)*ELABED(1)))
      SIGMANEQ(2,3) = SNEQ_TEM*(ELABE(2,3)- 3.*ORDPARA/2./
     +    (1.+2.*ORDPARA)*(DIR(2)*ELABED(3) + DIR(3)*ELABED(2)))
      SIGMANEQ(2,1) = SIGMANEQ(1,2)
      SIGMANEQ(3,1) = SIGMANEQ(1,3)
      SIGMANEQ(3,2) = SIGMANEQ(2,3)

      STRESS_OUTPUT = SIGMAEQ + SIGMANEQ
      RETURN
      END SUBROUTINE SIGMA_BAR

      SUBROUTINE PK1(PROPS, DEFGRD, DEFGRDV, DIR, STRESS_OUTPUT)
! CALCULATE PK1 STRESS
      IMPLICIT NONE
      REAL*8 PROPS(12), DEFGRD(3,3), DEFGRDV(3,3), DIR(3), 
     +    STRESS_OUTPUT(3,3)
      REAL*8 CAUCHYSTRESS(3,3), DEFGRD_INV(3,3), JCB
      INTEGER I, J

      CALL DET(DEFGRD, JCB)
      CALL MATINV3D(DEFGRD, DEFGRD_INV)
      CALL SIGMA(PROPS, DEFGRD, DEFGRDV, DIR, CAUCHYSTRESS)
      DO I = 1,3
      DO J = 1,3
      STRESS_OUTPUT(I,J) = 0.
      END DO
      END DO
      STRESS_OUTPUT = JCB*MATMUL(CAUCHYSTRESS,TRANSPOSE(DEFGRD_INV))

      RETURN
      END SUBROUTINE

      SUBROUTINE CAL_ELAB(PROPS, DEFGRD, DEFGRDV, DIR, ELAB, ELABE)
! CALCULATE ELASTIC CAUCHY-LAGRANGE TENSOR BG AND BGe
      IMPLICIT NONE
      REAL*8 PROPS(12), DIR(3), ELAB(3,3), ELABE(3,3), 
     +        DEFGRDV(3,3), DEFGRD(3,3)
      REAL*8 SHATEN(3,3), SHATEN0(3,3), DEFGRDE(3,3)

! CALCULATE RELATIVE VARIABLES
      CALL CAL_SHAPETENSOR(PROPS, DIR, SHATEN, SHATEN0)
      CALL CAL_DEFGRDE(DEFGRD, DEFGRDV, DEFGRDE)

! CALCULATE ELASTIC B
      ELAB = MATMUL(DEFGRD,MATMUL(SHATEN0,TRANSPOSE(DEFGRD)))
      ELABE = MATMUL(DEFGRDE,MATMUL(SHATEN0,TRANSPOSE(DEFGRDE)))

      RETURN
      END SUBROUTINE

      SUBROUTINE CAL_ELAI(PROPS, DEFGRD, DEFGRDV, DIR, ELAI, ELAIE)
! CALCULATE INVARIANTS CORRESPONDING TO BG AND BGe
      IMPLICIT NONE
      REAL*8 PROPS(12), DEFGRD(3,3), DEFGRDV(3,3), DIR(3), ELAI, ELAIE
      REAL*8 TEM(3,3), TEM1(3,3), SHATEN(3,3), SHATEN0(3,3), 
     +	DEFGRDE(3,3), SHATEN_INV(3,3)

! CALCULATE RELATIVE VARIABLES
      CALL CAL_DEFGRDE(DEFGRD, DEFGRDV, DEFGRDE)
      CALL CAL_SHAPETENSOR(PROPS, DIR, SHATEN, SHATEN0)
      CALL MATINV3D(SHATEN, SHATEN_INV)

! CALCULATE ELASTIC INVARIANTS
      TEM = MATMUL(MATMUL(SHATEN0,TRANSPOSE(DEFGRD)),
     +	MATMUL(SHATEN_INV,DEFGRD))
      TEM1 = MATMUL(MATMUL(SHATEN0,TRANSPOSE(DEFGRDE)),
     +	MATMUL(SHATEN_INV,DEFGRDE))
      ELAI = TEM(1,1) + TEM(2,2) + TEM(3,3)
      ELAIE = TEM1(1,1) + TEM1(2,2) + TEM1(3,3)

      RETURN
      END SUBROUTINE

      SUBROUTINE CAL_DEFGRDE(DEFGRD, DEFGRDV, DEFGRDE)
! CALCULATE THE ELASTIC DEFORMATION GRADIENT Fe
      IMPLICIT NONE
      REAL*8 DEFGRD(3,3), DEFGRDV(3,3), DEFGRDE(3,3)
      REAL*8 DEFGRDV_INV(3,3)

! CALCULATE INVERSE MATRIX OF FV
      CALL MATINV3D(DEFGRDV, DEFGRDV_INV)
      DEFGRDE = MATMUL(DEFGRD, DEFGRDV_INV)
      RETURN
      END SUBROUTINE

      SUBROUTINE CAL_SHAPETENSOR(PROPS, DIR, SHATEN, SHATEN0)
! CALCULATE SHAPETENSORS
      IMPLICIT NONE
      REAL*8 PROPS(12), DIR(3), SHATEN(3,3), SHATEN0(3,3), DIR0(3), 
     +	ORDPARA, LPA, LPER

! ASSIGN MAT. PARA.
      ORDPARA = PROPS(1)
      LPA = 1 + 2*ORDPARA
      LPER = 1 - ORDPARA
      DIR0(1) = PROPS(8)
      DIR0(2) = PROPS(9)
      DIR0(3) = PROPS(10)

! CALCULATE SHATEN0
      SHATEN0(1,1) = (LPA - LPER)*DIR0(1)*DIR0(1) + LPER
      SHATEN0(2,2) = (LPA - LPER)*DIR0(2)*DIR0(2) + LPER
      SHATEN0(3,3) = (LPA - LPER)*DIR0(3)*DIR0(3) + LPER
      SHATEN0(1,2) = (LPA - LPER)*DIR0(1)*DIR0(2)
      SHATEN0(1,3) = (LPA - LPER)*DIR0(1)*DIR0(3)
      SHATEN0(2,3) = (LPA - LPER)*DIR0(2)*DIR0(3)
      SHATEN0(2,1) = SHATEN0(1,2)
      SHATEN0(3,1) = SHATEN0(1,3)
      SHATEN0(3,2) = SHATEN0(2,3)

! CALCULATE SHATEN
      SHATEN(1,1) = (LPA - LPER)*DIR(1)*DIR(1) + LPER
      SHATEN(2,2) = (LPA - LPER)*DIR(2)*DIR(2) + LPER
      SHATEN(3,3) = (LPA - LPER)*DIR(3)*DIR(3) + LPER
      SHATEN(1,2) = (LPA - LPER)*DIR(1)*DIR(2)
      SHATEN(1,3) = (LPA - LPER)*DIR(1)*DIR(3)
      SHATEN(2,3) = (LPA - LPER)*DIR(2)*DIR(3)
      SHATEN(2,1) = SHATEN(1,2)
      SHATEN(3,1) = SHATEN(1,3)
      SHATEN(3,2) = SHATEN(2,3)

      RETURN
      END SUBROUTINE

      SUBROUTINE CAL_BGD(PROPS, DEFGRD, DEFGRDV, DIR, 
     +	BGD, BGED, DBGD, DBGED)
      ! CALCULATE CORRESPONDING VARIABLES IN DIR. EVOLUTION
      ! BGD, BGED, DBGD, DBGED
      IMPLICIT NONE
      REAL*8 PROPS(12), DIR(3), DEFGRD(3,3), DEFGRDV(3,3), BGD(3), 
     +	BGED(3), DBGD, DBGED
      REAL*8 SHATEN(3,3), SHATEN0(3,3), ELAB(3,3), ELABE(3,3)

      ! CALCULATE SHAPE TENSORS
      CALL CAL_SHAPETENSOR(PROPS, DIR, SHATEN, SHATEN0)
      CALL CAL_ELAB(PROPS, DEFGRD, DEFGRDV, DIR, ELAB, ELABE)

      ! CALCULATE BGD, BGED
      BGD(1) = ELAB(1,1)*DIR(1) + ELAB(1,2)*DIR(2) + ELAB(1,3)*DIR(3)
      BGD(2) = ELAB(2,1)*DIR(1) + ELAB(2,2)*DIR(2) + ELAB(2,3)*DIR(3)
      BGD(3) = ELAB(3,1)*DIR(1) + ELAB(3,2)*DIR(2) + ELAB(3,3)*DIR(3)
      DBGD = DOT_PRODUCT(BGD, DIR)

      BGED(1) = ELABE(1,1)*DIR(1) + ELABE(1,2)*DIR(2) + 
     +	ELABE(1,3)*DIR(3)
      BGED(2) = ELABE(2,1)*DIR(1) + ELABE(2,2)*DIR(2) + 
     +	ELABE(2,3)*DIR(3)
      BGED(3) = ELABE(3,1)*DIR(1) + ELABE(3,2)*DIR(2) + 
     +	ELABE(3,3)*DIR(3)
      DBGED = DOT_PRODUCT(BGED, DIR)

      RETURN
      END SUBROUTINE

      SUBROUTINE RESDIR(PROPS, DEFGRD_N, DEFGRDV_N, DIR_N, DEFGRD, 
     +	DEFGRDV, DIR, DELTAT, RESIDUAL_OUTPUT)
! CALCULATE THE RESIDUAL OF DISCRITIZED DIRECTOR EVOLUTION EQUATION
      IMPLICIT NONE
! DECLARATION
      REAL*8 PROPS(12), DEFGRDV_N(3,3)
      REAL*8 DEFGRD_N(3,3), DEFGRD(3,3), DEFGRDV(3,3), DEFGRD_INV(3,3)
      REAL*8 SHATEN(3,3),SHATEN0(3,3),STRESS(3,3), ELAB(3,3), ELABE(3,3)
      REAL*8 DIR_N(3), DIR(3), DIR0(3), COMPEQ(3), COMPNEQ(3), 
     +	COMPDIR(3), BGD(3), BGED(3), TEM(3,3), TEMV(3)
      REAL*8 ORDPARA, LOCKLIM, MUEQ, MUNEQ, ETAD0, ETAN, STRCOE, 
     +	BULKPENALTY, DIRPENALTY
      REAL*8 DELTAT, ETAD, RESIDUAL_OUTPUT(3)
      REAL*8 ELAI, ELAIE, DBGD, DBGED, JCB
! ASSIGN VALUES FOR MATERIAL PROPERTIES
      ORDPARA = PROPS(1)
      LOCKLIM = PROPS(2)
      MUEQ = PROPS(3)
      MUNEQ = PROPS(4)
      ETAD0 = PROPS(5)
      ETAN = PROPS(6)
      STRCOE = PROPS(7)
      DIR0(1) = PROPS(8)
      DIR0(2) = PROPS(9)
      DIR0(3) = PROPS(10)
      BULKPENALTY = PROPS(11)
      DIRPENALTY = PROPS(12)

! CALCULATE STRESS
      CALL SIGMA(PROPS, DEFGRD_N, DEFGRDV_N, DIR_N, STRESS)

! CALCULATE ETAD
      CALL FETAD(PROPS, STRESS, ETAD)

! CALCULATE SHAPE TENSOR, ELASTIC B AND ELASTIC INVARIANTS
      CALL CAL_SHAPETENSOR(PROPS, DIR, SHATEN, SHATEN0)
      CALL CAL_ELAB(PROPS, DEFGRD, DEFGRDV, DIR, ELAB, ELABE)
      CALL CAL_ELAI(PROPS, DEFGRD, DEFGRDV, DIR, ELAI, ELAIE)
      CALL CAL_BGD(PROPS, DEFGRD, DEFGRDV, DIR, BGD, BGED, DBGD, DBGED)

      COMPEQ = -MUEQ*(3.*ORDPARA)/(1 - ORDPARA)/(1 + 2*ORDPARA)*
     +	LOCKLIM/(LOCKLIM - (ELAI - 3))*(BGD - DBGD*DIR)
      COMPNEQ = -MUNEQ*(3.*ORDPARA)/(1 - ORDPARA)/(1 + 2*ORDPARA)*
     +	LOCKLIM/(LOCKLIM - (ELAIE - 3))*(BGED - DBGED*DIR)
      COMPDIR = DIRPENALTY * (1 - DOT_PRODUCT(DIR,DIR))**2*DIR

      ! RESIDUAL
      CALL MATINV3D(DEFGRD, DEFGRD_INV)
      TEM = 0.5*(MATMUL(TRANSPOSE(DEFGRD_INV),TRANSPOSE(DEFGRD_N)) 
     +	- MATMUL(DEFGRD_N,DEFGRD_INV))
      CALL MATVEC(TEM, DIR, 3, 3, TEMV)
      CALL DET(DEFGRD, JCB)
      RESIDUAL_OUTPUT = DIR - DIR_N - TEMV  + DELTAT/ETAD/JCB * 
     +	(COMPEQ + COMPNEQ - COMPDIR)

      RETURN
      END SUBROUTINE

      SUBROUTINE RESDEFGRDV(PROPS, DEFGRDV_N, DEFGRD, DEFGRDV, DIR, 
     +	DELTAT, RESIDUAL_OUTPUT)
! CALCULATE THE RESIDUAL OF DISCRETIZED EVOLUTION EQUATION OF DEFGRDV
      IMPLICIT NONE
! DECLARATION
      REAL*8 PROPS(12), DEFGRDV_N(3,3), DEFGRD(3,3), DEFGRDV(3,3), 
     +	DIR(3), RESIDUAL_OUTPUT(3,3)
      REAL*8 DEFGRDV_INV(3,3), DEFGRDE(3,3), SHATEN(3,3), 
     +	SHATEN0(3,3), ELAB(3,3), ELABE(3,3)
      REAL*8 TEM(3,3), TEM1(3,3), SHATEN_INV(3,3)
      REAL*8 DELTAT, MUNEQ, ETAN, LOCKLIM, ELAI, ELAIE

! ASSIGN MATERIAL PARAMETERS
      LOCKLIM = PROPS(2)
      MUNEQ = PROPS(4)
      ETAN = PROPS(6)

! CALCULATE SHAPE TENSOR, ELASTIC B AND INVARIANTS
      CALL CAL_SHAPETENSOR(PROPS, DIR, SHATEN, SHATEN0)
      CALL CAL_ELAB(PROPS, DEFGRD, DEFGRDV, DIR, ELAB, ELABE)
      CALL CAL_ELAI(PROPS, DEFGRD, DEFGRDV, DIR, ELAI, ELAIE)
      CALL CAL_DEFGRDE(DEFGRD, DEFGRDV, DEFGRDE)

! RESIDUAL
      CALL MATINV3D(SHATEN, SHATEN_INV)
      CALL MATINV3D(DEFGRDV, DEFGRDV_INV)

      TEM = MATMUL(DEFGRDV_N, DEFGRDV_INV)
      TEM1 = MATMUL(MATMUL(TRANSPOSE(DEFGRDE),SHATEN_INV),
     +	MATMUL(DEFGRDE,SHATEN0))
      RESIDUAL_OUTPUT(1,1) = 1 - TEM(1,1) - MUNEQ*DELTAT/ETAN*
     +	(LOCKLIM/(LOCKLIM - (ELAIE - 3))*TEM1(1,1) - 1)
      RESIDUAL_OUTPUT(1,2) = 0 - TEM(1,2) - MUNEQ*DELTAT/ETAN*
     +	(LOCKLIM/(LOCKLIM - (ELAIE - 3))*TEM1(1,2) - 0)
      RESIDUAL_OUTPUT(1,3) = 0 - TEM(1,3) - MUNEQ*DELTAT/ETAN*
     +	(LOCKLIM/(LOCKLIM - (ELAIE - 3))*TEM1(1,3) - 0)
      RESIDUAL_OUTPUT(2,1) = 0 - TEM(2,1) - MUNEQ*DELTAT/ETAN*
     +	(LOCKLIM/(LOCKLIM - (ELAIE - 3))*TEM1(2,1) - 0)
      RESIDUAL_OUTPUT(2,2) = 1 - TEM(2,2) - MUNEQ*DELTAT/ETAN*
     +	(LOCKLIM/(LOCKLIM - (ELAIE - 3))*TEM1(2,2) - 1)
      RESIDUAL_OUTPUT(2,3) = 0 - TEM(2,3) - MUNEQ*DELTAT/ETAN*
     +	(LOCKLIM/(LOCKLIM - (ELAIE - 3))*TEM1(2,3) - 0)
      RESIDUAL_OUTPUT(3,1) = 0 - TEM(3,1) - MUNEQ*DELTAT/ETAN*
     +	(LOCKLIM/(LOCKLIM - (ELAIE - 3))*TEM1(3,1) - 0)
      RESIDUAL_OUTPUT(3,2) = 0 - TEM(3,2) - MUNEQ*DELTAT/ETAN*
     +	(LOCKLIM/(LOCKLIM - (ELAIE - 3))*TEM1(3,2) - 0)
      RESIDUAL_OUTPUT(3,3) = 1 - TEM(3,3) - MUNEQ*DELTAT/ETAN*
     +	(LOCKLIM/(LOCKLIM - (ELAIE - 3))*TEM1(3,3) - 1)

      RETURN
      END SUBROUTINE

      SUBROUTINE PAR_IF_PAR_F(DEFGRD, OUTPUT)
! CALCULATE TAGENT iF TO F
      IMPLICIT NONE
      REAL*8 DEFGRD(3,3), OUTPUT(3,3,3,3), DEFGRD_INV(3,3)
      INTEGER I, A, J, B

! CALCULATE THE INVERSE OF F
      CALL MATINV3D(DEFGRD, DEFGRD_INV)

! INITIALIZATION
      DO A = 1,3
      DO I = 1,3
      DO J = 1,3
            DO B = 1,3
            OUTPUT(A,I,J,B) = 0.
            END DO
      END DO
      END DO
      END DO

! ASSIGN VALUES
      DO A = 1,3
      DO I = 1,3
      DO J = 1,3
            DO B = 1,3
            OUTPUT(A,I,J,B) = -DEFGRD_INV(A,J)*DEFGRD_INV(B,I)
            END DO
      END DO
      END DO
      END DO

      RETURN
      END SUBROUTINE

      SUBROUTINE PAR_FE_PAR_FV(DEFGRD, DEFGRDV, RESOUT)
! CALCULATE THE DERIVATIVE OF Fe TO Fv
      IMPLICIT NONE
      REAL*8 DEFGRD(3,3), DEFGRDV(3,3),RESOUT(3,3,3,3),DEFGRDV_INV(3,3)
      INTEGER I, ALPHA, BETA, A, B

! CALCULATE THE DERIVATIVE
      CALL MATINVMD(DEFGRDV, 3, DEFGRDV_INV)

      ! INITIALIZATION
      DO I = 1,3
      DO ALPHA = 1,3
      DO BETA = 1,3
            DO A = 1,3
            RESOUT(I, ALPHA, BETA, A) = 0.
            END DO
      END DO
      END DO
      END DO

! CALCULATE COMPONENTS
      DO I = 1,3
      DO ALPHA = 1,3
      DO BETA = 1,3
      DO A = 1,3
      DO B = 1,3
      RESOUT(I, ALPHA, BETA, A) = RESOUT(I, ALPHA, BETA, A) - 
     +	DEFGRD(I, B)*DEFGRDV_INV(B, BETA)*DEFGRDV_INV(A, ALPHA)
      END DO
      END DO
      END DO
      END DO
      END DO

      RETURN

      END SUBROUTINE

      SUBROUTINE PAR_BGE_PAR_F(PROPS, DEFGRD, DEFGRDV, DIR, RESOUT)
! CALCULATE THE DERIVATIVE OF ELASTIC BE TO F
      IMPLICIT NONE
      REAL*8 PROPS(12), DEFGRD(3,3), DEFGRDV(3,3), DIR(3), 
     +	DEFGRDE(3,3), RESOUT(3,3,3,3)
      REAL*8 SHATEN(3,3), SHATEN0(3,3), ELAB(3,3), ELABE(3,3), ELAI, 
     +	ELAIE, FEF(3,3,3,3)
      INTEGER M, N, ALPHA, BETA, J, B

! CALCULATE F_e
      CALL CAL_DEFGRDE(DEFGRD, DEFGRDV, DEFGRDE)

! CALCULATE CORRESPONDING VARIABLES IN SOFT-ELASTICITY
      CALL CAL_SHAPETENSOR(PROPS, DIR, SHATEN, SHATEN0)
      CALL CAL_ELAB(PROPS, DEFGRD, DEFGRDV, DIR, ELAB, ELABE)
      CALL CAL_ELAI(PROPS, DEFGRD, DEFGRDV, DIR, ELAI, ELAIE)

! CALCULATE DERIVATIVE FeF
      CALL PAR_FE_PAR_F(DEFGRDV, FEF)

! INITIALIZE RES
      DO M = 1,3
      DO N = 1,3
      DO J = 1,3
      DO B = 1,3
      RESOUT(M, N, J, B) = 0.
      END DO
      END DO
      END DO
      END DO

! ASSIGN VALUES FOR
      DO M = 1,3
      DO N = 1,3
      DO ALPHA = 1,3
      DO BETA = 1,3
      DO J = 1,3
      DO B = 1,3
      RESOUT(M, N, J, B) = RESOUT(M, N, J, B) + SHATEN0(ALPHA, BETA)*
     +	(FEF(M, ALPHA, J, B)*DEFGRDE(N, BETA)
     +	+ FEF(N, BETA, J, B)*DEFGRDE(M, ALPHA))
      END DO
      END DO
      END DO
      END DO
      END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE PAR_FE_PAR_F(DEFGRDV, RESOUT)
! CALCULATE THE DERIVATIVE OF F TO FE
      IMPLICIT NONE
      REAL*8 DEFGRDV(3,3), DEFGRDV_INV(3,3), RESOUT(3,3,3,3), KCRON(3,3)
      INTEGER I, M, A, ALPHA

! CALCLULATE INVERSE OF FV
      CALL MATINV3D(DEFGRDV, DEFGRDV_INV)

! GENERATE AN IDENTITY MATRIX
      CALL IDGENERATION(KCRON)

! ASSIGN VALUES FOR RES
      DO I = 1,3
      DO M = 1,3
      DO A = 1,3
      DO ALPHA = 1,3
      RESOUT(M, ALPHA, I, A) = KCRON(I,M)*DEFGRDV_INV(A,ALPHA)
      END DO
      END DO
      END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE PAR_BGE_PAR_FV(PROPS, DEFGRD, DEFGRDV, DIR, RESOUT)
! CALCULATE THE DERIVATIVE Be TO Fv
      IMPLICIT NONE
      REAL*8 PROPS(12), DEFGRD(3,3), DEFGRDV(3,3), DIR(3), 
     +	RESOUT(3,3,3,3), FEFV(3,3,3,3)
      REAL*8 DEFGRDE(3,3), SHATEN(3,3), SHATEN0(3,3), ELAB(3,3), 
     +	ELABE(3,3), ELAI, ELAIE
      INTEGER I, M, ALPHA, A, KSI, ETA

! CALCULATE CORRESPONDING VARIABLES IN SOFT-ELASTICITY
      CALL CAL_DEFGRDE(DEFGRD, DEFGRDV, DEFGRDE)
      CALL CAL_SHAPETENSOR(PROPS, DIR, SHATEN, SHATEN0)
      CALL CAL_ELAB(PROPS, DEFGRD, DEFGRDV, DIR, ELAB, ELABE)
      CALL CAL_ELAI(PROPS, DEFGRD, DEFGRDV, DIR, ELAI, ELAIE)

! CALCULATE THE DERIVATIVE OF Fe TO Fv
      CALL PAR_FE_PAR_FV(DEFGRD, DEFGRDV, FEFV)

! INITIALIZATION
      DO I = 1,3
      DO M = 1,3
      DO ALPHA = 1,3
      DO A = 1,3
      RESOUT(I, M, ALPHA, A) = 0.
      END DO
      END DO
      END DO
      END DO

! CALCULATE COMPONENTS
      DO I = 1,3
      DO M = 1,3
      DO ALPHA = 1,3
      DO A = 1,3
      DO KSI = 1,3
      DO ETA = 1,3
      RESOUT(I, M, ALPHA, A) = RESOUT(I, M, ALPHA, A) + 
     +	SHATEN0(KSI, ETA)*(FEFV(I, KSI, ALPHA, A)*DEFGRDE(M, ETA) + 
     +	FEFV(M, ETA, ALPHA, A)*DEFGRDE(I, KSI))
      END DO
      END DO
      END DO
      END DO
      END DO
      END DO

      RETURN

      END SUBROUTINE

      SUBROUTINE PAR_BG_PAR_F(PROPS, DEFGRD, DEFGRDV, DIR, RESOUT)
! CALCULATE THE DERIVATIVE OF BG TO F
      IMPLICIT NONE
      REAL*8 PROPS(12), DEFGRD(3,3), DEFGRDV(3,3),DIR(3),RESOUT(3,3,3,3)
      REAL*8 SHATEN(3,3), SHATEN0(3,3), ELAB(3,3), ELABE(3,3), 
     +	ELAI, ELAIE, KCRON(3,3)
      INTEGER I, M, J, B, C, D

! CALCULATE CORRESPONDING VARIABLES IN SOFT-ELASTICITY
      CALL CAL_SHAPETENSOR(PROPS, DIR, SHATEN, SHATEN0)
      CALL CAL_ELAB(PROPS, DEFGRD, DEFGRDV, DIR, ELAB, ELABE)
      CALL CAL_ELAI(PROPS, DEFGRD, DEFGRDV, DIR, ELAI, ELAIE)

! GENERATE IDENTITY MATRIX
      CALL IDGENERATION(KCRON)

! INITIALIZATION
      DO I = 1,3
      DO M = 1,3
      DO J = 1,3
      DO B = 1,3
      RESOUT(I, M, J, B) = 0.
      END DO
      END DO
      END DO
      END DO

! CALCULATE COMPONENTS
      DO I = 1,3
      DO M = 1,3
      DO J = 1,3
      DO B = 1,3
      DO C = 1,3
      DO D = 1,3
      RESOUT(I, M, J, B) = RESOUT(I, M, J, B) + SHATEN0(C, D)* 
     +	(KCRON(I, J)*KCRON(B, C)*DEFGRD(M, D) + 
     +      DEFGRD(I, C)*KCRON(M, J)*KCRON(B, D))
      END DO
      END DO
      END DO
      END DO
      END DO
      END DO

      RETURN

      END SUBROUTINE

      SUBROUTINE PAR_IN_PAR_D(PROPS, DEFGRD, DIR, OUTPUT)
! CALCULATE DERIVATIVE OF IN TO d
      IMPLICIT NONE
      REAL*8 PROPS(12), DEFGRD(3,3), DIR(3)
      REAL*8 SHATEN0(3,3), ORDPARA, LPA, LPER, DIR0(3), OUTPUT(3)
      INTEGER A, B, K, M

! ASSIGN MATERIAL PARAMETERS
      ORDPARA = PROPS(1)
      LPA = 1. + 2.*ORDPARA
      LPER = 1. - ORDPARA
      DIR0(1) = PROPS(8)
      DIR0(2) = PROPS(9)
      DIR0(3) = PROPS(10)

! CALCULATE SHAPE TENSOR
      SHATEN0(1,1) = (LPA-LPER)*(DIR0(1)*DIR0(1))+LPER
      SHATEN0(2,2) = (LPA-LPER)*(DIR0(2)*DIR0(2))+LPER
      SHATEN0(3,3) = (LPA-LPER)*(DIR0(3)*DIR0(3))+LPER
      SHATEN0(1,2) = (LPA-LPER)*(DIR0(1)*DIR0(2))
      SHATEN0(1,3) = (LPA-LPER)*(DIR0(1)*DIR0(3))
      SHATEN0(2,3) = (LPA-LPER)*(DIR0(2)*DIR0(3))
      SHATEN0(2,1) = SHATEN0(1,2)
      SHATEN0(3,1) = SHATEN0(1,3)
      SHATEN0(3,2) = SHATEN0(2,3)

! INITIALIZATION
      OUTPUT = [0., 0., 0.]

! ASSIGN VALUES
      DO A = 1,3
      DO B = 1,3
      DO K = 1,3
      DO M = 1,3
      OUTPUT(K) = OUTPUT(K)+SHATEN0(A,B)*DEFGRD(K,A)*DEFGRD(M,B)*DIR(M)
      END DO
      END DO
      END DO
      END DO

      OUTPUT = 2.*(1/LPA - 1/LPER)*OUTPUT
      RETURN
      END SUBROUTINE

      SUBROUTINE PAR_INE_PAR_D(PROPS, DEFGRD, DEFGRDV, DIR, OUTPUT)
! CALCULATE DERIVATIVE OF INE TO d
      IMPLICIT NONE
      REAL*8 PROPS(12), DEFGRD(3,3), DEFGRDV(3,3), DIR(3), KCRON(3,3)
      REAL*8 ORDPARA, DIR0(3), LPA, LPER, SHATEN0(3,3), DEFGRDE(3,3), 
     +	OUTPUT(3)
      INTEGER ALPHA, BETA, I, J, K

! ASSIGN MATERIAL PARAMETERS
      ORDPARA = PROPS(1)
      LPA = 1. + 2.*ORDPARA
      LPER = 1. - ORDPARA
      DIR0(1) = PROPS(8)
      DIR0(2) = PROPS(9)
      DIR0(3) = PROPS(10)

! CALCULATE SHAPE TENSOR
      SHATEN0(1,1) = (LPA-LPER)*(DIR0(1)*DIR0(1))+LPER
      SHATEN0(2,2) = (LPA-LPER)*(DIR0(2)*DIR0(2))+LPER
      SHATEN0(3,3) = (LPA-LPER)*(DIR0(3)*DIR0(3))+LPER
      SHATEN0(1,2) = (LPA-LPER)*(DIR0(1)*DIR0(2))
      SHATEN0(1,3) = (LPA-LPER)*(DIR0(1)*DIR0(3))
      SHATEN0(2,3) = (LPA-LPER)*(DIR0(2)*DIR0(3))
      SHATEN0(2,1) = SHATEN0(1,2)
      SHATEN0(3,1) = SHATEN0(1,3)
      SHATEN0(3,2) = SHATEN0(2,3)

! CALCULATE Fe
      CALL CAL_DEFGRDE(DEFGRD, DEFGRDV, DEFGRDE)

! GENERATE IDENTITY MATRIX
      CALL IDGENERATION(KCRON)

! INITIALIZATIION
      OUTPUT = [0., 0., 0.]

! ASSIGN VALUES
      DO ALPHA = 1,3
      DO BETA = 1,3
      DO I = 1,3
      DO J = 1,3
      DO K = 1,3
      OUTPUT(K) = OUTPUT(K) + (1./LPA - 1./LPER)*SHATEN0(ALPHA,BETA)
     +	*DEFGRDE(I,ALPHA) 
     +      *DEFGRDE(J,BETA)*(KCRON(I,K)*DIR(J) + KCRON(J,K)*DIR(I))
      END DO
      END DO
      END DO
      END DO
      END DO

      RETURN
      END SUBROUTINE      

      SUBROUTINE PAR_IN_PAR_F(PROPS, DEFGRD, DIR, RESOUT)
! CALCULATE THE TANGENT IN TO F
      IMPLICIT NONE
      REAL*8 PROPS(12), DEFGRD(3,3), DIR(3), RESOUT(3,3)
      REAL*8 SHATEN(3,3), SHATEN0(3,3), SHATEN_INV(3,3), KCRON(3,3)
      INTEGER I, J, M, N, C, D, B

! CAL. SHATEN, SHATEN0, SHATAN_INV
      CALL CAL_SHAPETENSOR(PROPS, DIR, SHATEN, SHATEN0)
      CALL MATINV3D(SHATEN, SHATEN_INV)

! CREATE ID MATRIX
      CALL IDGENERATION(KCRON)

! INITIALIZE
      DO I = 1,3
      DO J = 1,3
      RESOUT(I,J) = 0.
      END DO
      END DO

! ASSIGN VALUES
      DO M = 1,3
      DO N = 1,3
      DO C = 1,3
      DO D = 1,3
      DO J = 1,3
      DO B = 1,3
      RESOUT(J,B) = RESOUT(J,B) + SHATEN0(C,D)*SHATEN_INV(M,N)*
     +		(KCRON(M,J)*KCRON(B,C)*DEFGRD(N,D)
     +		+ KCRON(J,N)*KCRON(B,D)*DEFGRD(M,C))
      END DO
      END DO
      END DO
      END DO
      END DO
      END DO

      RETURN
      END SUBROUTINE

      SUBROUTINE PAR_INE_PAR_F(PROPS, DEFGRD, DEFGRDV, DIR, RESOUT)
! CALCULATE TAGENT INe TO F
      IMPLICIT NONE
      REAL*8 PROPS(12), DEFGRD(3,3), DEFGRDV(3,3), DIR(3), RESOUT(3,3)
      REAL*8 SHATEN(3,3), SHATEN0(3,3), SHATEN_INV(3,3), 
     +		DEFGRDE(3,3), FEF(3,3,3,3)
      INTEGER J, ALPHA, BETA, M, N, I, A

      ! CALCULATE Fe
      CALL CAL_DEFGRDE(DEFGRD, DEFGRDV, DEFGRDE)
      CALL CAL_SHAPETENSOR(PROPS, DIR, SHATEN, SHATEN0)
      CALL PAR_FE_PAR_F(DEFGRDV, FEF)
      CALL MATINV3D(SHATEN, SHATEN_INV)

      ! INITIALIZE
      DO I = 1,3
      DO J = 1,3
      RESOUT(I,J) = 0.
      END DO
      END DO

! ASSIGN VALUES
      DO ALPHA = 1,3
      DO BETA = 1,3
      DO M = 1,3
      DO N = 1,3
      DO I = 1,3
      DO A = 1,3
      RESOUT(I,A) = RESOUT(I,A) + SHATEN0(ALPHA,BETA)*SHATEN_INV(M,N)*
     +		(FEF(M,ALPHA,I,A)*DEFGRDE(N,BETA)
     +            + DEFGRDE(M,ALPHA)*FEF(N,BETA,I,A))
      END DO
      END DO
      END DO
      END DO
      END DO
      END DO

      RETURN
      END SUBROUTINE

      SUBROUTINE PAR_INE_PAR_FV(PROPS, DEFGRD, DEFGRDV, DIR, RESOUT)
! CALCULATE TAGENT INe TO Fv
      IMPLICIT NONE
      REAL*8 PROPS(12), DEFGRD(3,3), DEFGRDV(3,3), RESOUT(3,3), DIR(3)
      REAL*8 DEFGRDE(3,3), SHATEN(3,3), SHATEN0(3,3), 
     +	SHATEN_INV(3,3), FEFV(3,3,3,3), TEM(3,3)
      INTEGER M, N, ALPHA, A, KSI, ETA

! CALCULATE LOCAL VARIABLES
      CALL CAL_DEFGRDE(DEFGRD, DEFGRDV, DEFGRDE)
      CALL CAL_SHAPETENSOR(PROPS, DIR, SHATEN, SHATEN0)
      CALL PAR_FE_PAR_FV(DEFGRD, DEFGRDV, FEFV)
      CALL MATINV3D(SHATEN, SHATEN_INV)

! INITIALIZE TEM
      DO ALPHA = 1,3
      DO A = 1,3
      TEM(ALPHA, A) = 0.
      END DO
      END DO

      ! ASSIGN VALUES
      DO M = 1,3
      DO N = 1,3
      DO ALPHA = 1,3
      DO A = 1,3
      DO KSI = 1,3
      DO ETA = 1,3
      TEM(ALPHA, A) = TEM(ALPHA, A) + SHATEN0(KSI,ETA)*SHATEN_INV(M,N)*
     +			(FEFV(M,KSI,ALPHA,A)*DEFGRDE(N,ETA)
     +                  + FEFV(N,ETA,ALPHA,A)*DEFGRDE(M,KSI))
      END DO
      END DO
      END DO
      END DO
      END DO
      END DO
      RESOUT = TEM
      RETURN
      END SUBROUTINE

      SUBROUTINE PAR_IL_PAR_D(PROPS, DIR, RESOUT)
! CALCULATE TAGENT iL TO d
      IMPLICIT NONE
      REAL*8 PROPS(12), DIR(3), RESOUT(3,3,3), KCRON(3,3)
      REAL*8 LPA, LPER, ORDPARA
      INTEGER M, N, K

      ORDPARA = PROPS(1)
      LPA = 1 + 2.*ORDPARA
      LPER = 1 - ORDPARA
      CALL IDGENERATION(KCRON)  ! GENERATE AN ID MATRIX

! ASSIGN VALUES
      DO M = 1,3
      DO N = 1,3
      DO K = 1,3
      RESOUT(M,N,K) = (1/LPA - 1/LPER)*(KCRON(M,K)*DIR(N) + 
     +		KCRON(N,K)*DIR(M))
      END DO
      END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE PAR_F_PAR_D(PROPS, DEFGRD_N, DEFGRDV_N, DIR_N, 
     +		DEFGRD, DEFGRDV, DIR, DELTAT, RESOUT)
      ! CALCULATE THE DERIVATIVE OF f TO d
      IMPLICIT NONE
      REAL*8 PROPS(12), DEFGRD_N(3,3), DEFGRDV_N(3,3), DIR_N(3), 
     +	DEFGRD(3,3), DEFGRDV(3,3), DIR(3), RESOUT(3,3)
      REAL*8 SHATEN(3,3), SHATEN0(3,3), SHATEN_INV(3,3), 
     +	DEFGRD_INV(3,3), STRESS(3,3)
      REAL*8 ELAB(3,3), ELABE(3,3), ELAI, ELAIE
      REAL*8 ETAD, DELTAT, KCRON(3,3), DIRPENALTY
      REAL*8 TEM1(3,3), TEM20(3), TEM20E(3), TEM2(3,3), TEM2E(3,3), 
     +	IND(3), INED(3), TEM3(3,3), TEM3E(3,3)
      REAL*8 TEM4(3,3), TEM4E(3,3), MEQD(3,3), MNEQD(3,3), TEM5(3,3)
      REAL*8 BGD(3), BGED(3), DBGD, DBGED
      REAL*8 MUEQ, MUNEQ, ORDPARA, LOCKLIM, JCB
      INTEGER I, K, A, M, P, Q

! ASSIGN MATERIAL PARAMETERS
      ORDPARA = PROPS(1)
      MUEQ = PROPS(3)
      MUNEQ = PROPS(4)
      LOCKLIM = PROPS(2)
      DIRPENALTY = PROPS(12)

! CALCULATE CORRESPONDING VARIABLES IN SOFT-ELASTICITY
      CALL CAL_SHAPETENSOR(PROPS, DIR, SHATEN, SHATEN0)
      CALL CAL_ELAB(PROPS, DEFGRD, DEFGRDV, DIR, ELAB, ELABE)
      CALL CAL_ELAI(PROPS, DEFGRD, DEFGRDV, DIR, ELAI, ELAIE)

! CALCULATE INVERSE OF F AND L
      CALL MATINV3D(DEFGRD, DEFGRD_INV)
      CALL MATINV3D(SHATEN, SHATEN_INV)

! CALCULATE STRESS
      CALL SIGMA(PROPS, DEFGRD_N, DEFGRDV_N, DIR_N, STRESS)

! CALCULATE VISCO COEFFICINET
      CALL FETAD(PROPS, STRESS, ETAD)

! GENERATE AN IDENTITY MATRIX
      CALL IDGENERATION(KCRON)

! CALCULATE THE COMP. 1
! INITIALIZATION
      DO I = 1,3
      DO K = 1,3
      TEM1(I,K) = 0.
      END DO
      END DO

! ASSIGN VALUES
      DO I = 1,3
      DO A = 1,3
      DO M = 1,3
      DO K = 1,3
      TEM1(I, K) = (DEFGRD_INV(A,I)*DEFGRD_N(M,A) - DEFGRD_N(I,A)*
     +		DEFGRD_INV(A,M))*KCRON(M, K)
      END DO
      END DO
      END DO
      END DO
      TEM1 = KCRON - 0.5*TEM1

! CALCULATE COMP. 2
! CALCULATE BGD, BGED, DBGD, DBGED
      CALL CAL_BGD(PROPS, DEFGRD, DEFGRDV, DIR, BGD, BGED, DBGD, DBGED)

      TEM20 = BGD - DBGD*DIR
      TEM20E = BGED - DBGED*DIR

! CALCULATE INd, INed
      CALL PAR_IN_PAR_D(PROPS, DEFGRD, DIR, IND)
      CALL PAR_INE_PAR_D(PROPS, DEFGRD, DEFGRDV, DIR, INED)

! INITIALIZATION
      DO I = 1,3
      DO K = 1,3
      TEM2(I,K) = 0.
      TEM2E(I,K) = 0.
      END DO
      END DO

! ASSIGN VALUES
      DO I = 1,3
      DO K = 1,3
      TEM2(I,K) = IND(K)*TEM20(I)
      TEM2E(I,K) = INED(K)*TEM20E(I)
      END DO
      END DO

! CALCULATE COMP. 3
! INITIALIZATION
      DO I = 1,3
      DO K = 1,3
      TEM3(I,K) = 0.
      TEM3E(I,K) = 0.
      END DO
      END DO

! ASSIGN VALUES
      DO I = 1,3
      DO M = 1,3
      DO K = 1,3
      TEM3(I,K) = TEM3(I,K) + ELAB(I,M)*KCRON(M,K)
      TEM3E(I,K) = TEM3E(I,K) + ELABE(I,M)*KCRON(M,K)
      END DO
      END DO
      END DO

! CALCULATE COMP. 4
! INITIALIZATION
      DO I = 1,3
      DO K = 1,3
      TEM4(I,K) = 0.
      TEM4E(I,K) = 0.
      END DO
      END DO

! ASSIGN VALUES
      DO P = 1,3
      DO Q = 1,3
      DO K = 1,3
      DO I = 1,3
      TEM4(I,K) = TEM4(I,K) + ELAB(P,Q)*(KCRON(P,K)*DIR(Q)*DIR(I)
     +	    + KCRON(Q,K)*DIR(P)*DIR(I) + KCRON(I,K)*DIR(P)*DIR(Q))
      TEM4E(I,K) = TEM4E(I,K) + ELABE(P,Q)*(KCRON(P,K)*DIR(Q)*DIR(I)
     +          + KCRON(Q,K)*DIR(P)*DIR(I) + KCRON(I,K)*DIR(P)*DIR(Q))
      END DO
      END DO
      END DO
      END DO

! CALCULATE MEQD, MNEQD
      MEQD = - MUEQ*3.*ORDPARA/(1.-ORDPARA)/(1+2.*ORDPARA)*LOCKLIM/
     +	(LOCKLIM - (ELAI - 3))**2*(TEM2 + (LOCKLIM-(ELAI-3))*(TEM3-TEM4))
      MNEQD = - MUNEQ*3.*ORDPARA/(1.-ORDPARA)/(1+2.*ORDPARA)*LOCKLIM
     +	/(LOCKLIM - (ELAIE - 3))**2* 
     +	(TEM2E + (LOCKLIM-(ELAIE-3))*(TEM3E-TEM4E))

! CALCULATE COMP. 5
! INITIALIZATION
      DO I = 1,3
      DO K = 1,3
      TEM5(I,K) = 0.
      END DO
      END DO

! ASSIGN VALUES
      DO I = 1,3
      DO K = 1,3
      TEM5(I,K) = (1 - DOT_PRODUCT(DIR,DIR))**2*KCRON(I,K) 
     +		+ 4*(DOT_PRODUCT(DIR,DIR) - 1)
     +             *DIR(I)*DIR(K)
      END DO
      END DO

! OUTPUT
      CALL DET(DEFGRD, JCB)
      RESOUT = TEM1 + DELTAT/ETAD/JCB*(MEQD + MNEQD - DIRPENALTY*TEM5)
      RETURN
      END SUBROUTINE

      SUBROUTINE PAR_F_PAR_F(PROPS, DEFGRD_N, DEFGRDV_N, DIR_N, 
     +		DEFGRD, DEFGRDV, DIR, DELTAT, OUTPUT)
! CALCULATE THE TANGENT f TO F
      IMPLICIT NONE
      REAL*8 PROPS(12), DEFGRD_N(3,3), DEFGRDV_N(3,3), DIR_N(3), 
     +		DEFGRD(3,3), DEFGRDV(3,3), DIR(3), OUTPUT(3,3,3)
      REAL*8 ELAB(3,3), ELABE(3,3), ELAI, ELAIE
      REAL*8 K1(3,3,3), IFF(3,3,3,3), INF(3,3), INEF(3,3)
      REAL*8 MEQ, MNEQ, MUEQ, MUNEQ, ORDPARA, LOCKLIM, DELTAT
      REAL*8 BGF(3,3,3,3), BGEF(3,3,3,3), TEM1(3), TEM1E(3), 
     +		TEM2(3,3,3), TEM2E(3,3,3)
      REAL*8 TEM3(3,3,3), TEM3E(3,3,3), TEM4(3,3,3), TEM4E(3,3,3), 
     +		MEQF(3,3,3), MNEQF(3,3,3), K2(3,3,3), ETAD
      REAL*8 DBGD, DBGED, BGD(3), BGED(3), STRESS(3,3), JCB, JF(3,3)
      REAL*8 DIRPENALTY, MD(3), TEM_MD(3), TEM_J(3,3,3)
      INTEGER I, J, B, A, M, P, Q

! CALCULATE COMP. 1
      CALL PAR_IF_PAR_F(DEFGRD,IFF)
      CALL CAL_ELAI(PROPS, DEFGRD, DEFGRDV, DIR, ELAI, ELAIE)
! INITIALIZATION
      DO I = 1,3
      DO J = 1,3
      DO B = 1,3
      K1(I,J,B) = 0.
      END DO
      END DO
      END DO

! ASSIGN VALUES
      DO I = 1,3
      DO J = 1,3
      DO B = 1,3
      DO A = 1,3
      DO M = 1,3
      K1(I,J,B) = K1(I,J,B) - 0.5*(IFF(A,I,J,B)*DEFGRD_N(M,A) -
     +		DEFGRD_N(I,A)*IFF(A,M,J,B))*DIR(M)
      END DO
      END DO
      END DO
      END DO
      END DO

! CALCULATE MEQ, MNEQ, INF, INEF
! ASSIGN MATERIAL PROPERTIES
      ORDPARA = PROPS(1)
      LOCKLIM = PROPS(2)
      MUEQ = PROPS(3)
      MUNEQ = PROPS(4)

      ! CALCULATE MEQ AND MNEQ
      MEQ = -MUEQ*3.*ORDPARA/(1-ORDPARA)/(1+2*ORDPARA)*LOCKLIM/
     +	(LOCKLIM - (ELAI-3))
      MNEQ = -MUNEQ*3.*ORDPARA/(1-ORDPARA)/(1+2*ORDPARA)*LOCKLIM/
     +	(LOCKLIM - (ELAIE-3))

! CALCULATE INF AND INeF
      CALL PAR_IN_PAR_F(PROPS, DEFGRD, DIR, INF)
      CALL PAR_INE_PAR_F(PROPS, DEFGRD, DEFGRDV, DIR, INEF)

! CALCULATE BGF AND BGeF
      CALL PAR_BG_PAR_F(PROPS, DEFGRD, DEFGRDV, DIR, BGF)
      CALL PAR_BGE_PAR_F(PROPS, DEFGRD, DEFGRDV, DIR, BGEF)

! CALCULATE DBGD,DBGED
      CALL CAL_BGD(PROPS, DEFGRD, DEFGRDV, DIR, BGD, BGED, DBGD, DBGED)

! CALCULATE TEM1, TEM1E
      TEM1 = BGD - DBGD*DIR
      TEM1E = BGED - DBGED*DIR

! INITIALIZE TEM2, TEM2E, TEM3, TEM3E, TEM4, TEM4E
      DO I = 1,3
      DO J = 1,3
      DO B = 1,3
      TEM2(I,J,B) = 0.
      TEM2E(I,J,B) = 0.
      TEM3(I,J,B) = 0.
      TEM3E(I,J,B) = 0.
      TEM4(I,J,B) = 0.
      TEM4E(I,J,B) = 0.
      END DO
      END DO
      END DO

! ASSIGN VALUES FOR TEM2, TEM2E
      DO I = 1,3
      DO J = 1,3
      DO B = 1,3
      TEM2(I,J,B) = INF(J,B)*TEM1(I)
      TEM2E(I,J,B) = INEF(J,B)*TEM1E(I)
      END DO
      END DO
      END DO

! ASSIGN VALUES TEM3, TEM3E
      DO I = 1,3
      DO J = 1,3
      DO B = 1,3
      DO M = 1,3
      TEM3(I,J,B) = TEM3(I,J,B) + BGF(I,M,J,B)*DIR(M)
      TEM3E(I,J,B) = TEM3E(I,J,B) + BGEF(I,M,J,B)*DIR(M)
      END DO
      END DO
      END DO
      END DO

! ASSIGN VALUES FOR TEM4, TEM4E
      DO I = 1,3
      DO J = 1,3
      DO B = 1,3
      DO P = 1,3
      DO Q = 1,3
      TEM4(I,J,B) = TEM4(I,J,B) + DIR(P)*DIR(Q)*DIR(I)*BGF(P,Q,J,B)
      TEM4E(I,J,B) = TEM4E(I,J,B) + DIR(P)*DIR(Q)*DIR(I)*BGEF(P,Q,J,B)
      END DO
      END DO
      END DO
      END DO
      END DO

! CALCULATE MEQF, MNEQF
      MEQF = MEQ/(LOCKLIM - (ELAI - 3))*TEM2 + MEQ*(TEM3 - TEM4)
      MNEQF = MNEQ/(LOCKLIM - (ELAIE - 3))*TEM2E + MNEQ*(TEM3E - TEM4E)

! INITIALIZE K2
      K2 = MEQF + MNEQF

! CALCULATE ETAD
      CALL SIGMA(PROPS, DEFGRD_N, DEFGRDV_N, DIR_N, STRESS)
      CALL FETAD(PROPS, STRESS, ETAD)
      CALL DET(DEFGRD, JCB)
      CALL PAR_JCB_PAR_F(DEFGRD, JF)
      
      TEM1 = BGD - DBGD*DIR
      TEM1E = BGED - DBGED*DIR
      DIRPENALTY = PROPS(12)
      MD = -DIRPENALTY*(DOT_PRODUCT(DIR,DIR)-1)**2*DIR
      TEM_MD = MEQ*TEM1+MNEQ*TEM1E+MD
      TEM_J = 0.
      
      DO I = 1,3
          DO J = 1,3
              DO A = 1,3
                  TEM_J(I,J,A) = TEM_MD(I)*JF(J,A)
              END DO
          END DO
      END DO
      

! CALCULATE OUTPUT
      OUTPUT = K1 + DELTAT/ETAD/JCB*K2 -1./JCB**2*DELTAT/ETAD*TEM_J

      RETURN
      END SUBROUTINE

      SUBROUTINE PAR_F_PAR_FV(PROPS, DEFGRD_N, DEFGRDV_N, DIR_N, 
     +		DEFGRD, DEFGRDV, DIR, DELTAT, RESOUT)
! CALCULATE TAGENT f TO Fv
      IMPLICIT NONE
      REAL*8 PROPS(12), DEFGRD_N(3,3), DEFGRDV_N(3,3), DIR_N(3), 
     +		DEFGRD(3,3), DEFGRDV(3,3), DIR(3), RESOUT(3,3,3)
      REAL*8 DEFGRDE(3,3), SHATEN(3,3), SHATEN0(3,3), SHATEN_INV(3,3), 
     +		ELAI, ELAIE, ELAB(3,3), ELABE(3,3)
      REAL*8 INEFV(3,3), TEM0(3,3,3), TEM00(3), BGEFV(3,3,3,3), 
     +		TEM1(3,3,3), TEM2(3,3,3), STRESS(3,3), ETAD
      REAL*8 BGD(3), BGED(3), DBGD, DBGED, MNEQ, MNEQDFV(3,3,3), 
     +		LOCKLIM, ORDPARA, MUNEQ, DELTAT, JCB
      INTEGER I, ALPHA, A, M, P, Q

! CALCULATE LOCAL VARIABLES
      CALL CAL_DEFGRDE(DEFGRD, DEFGRDV, DEFGRDE)
      CALL CAL_SHAPETENSOR(PROPS, DIR, SHATEN, SHATEN0)
      CALL CAL_ELAB(PROPS, DEFGRD, DEFGRDV, DIR, ELAB, ELABE)
      CALL CAL_ELAI(PROPS, DEFGRD, DEFGRDV, DIR, ELAI, ELAIE)
      CALL MATINV3D(SHATEN, SHATEN_INV)
      CALL PAR_INE_PAR_FV(PROPS, DEFGRD, DEFGRDV, DIR, INEFV)
      CALL CAL_BGD(PROPS, DEFGRD, DEFGRDV, DIR, BGD, BGED, DBGD, DBGED)

! CAL. TEM00
      TEM00 = BGED - DBGED*DIR

!INITIALIZE TEM0, TEM1, TEM2
      DO I = 1,3
      DO ALPHA = 1,3
      DO A = 1,3
      TEM0(I,ALPHA,A) = 0.
      TEM1(I,ALPHA,A) = 0.
      TEM2(I,ALPHA,A) = 0.
      END DO
      END DO
      END DO

! ASSIGN VALUES FOR TEM0
      DO I = 1,3
      DO ALPHA = 1,3
      DO A = 1,3
      TEM0(I,ALPHA,A) = INEFV(ALPHA,A)*TEM00(I)
      END DO
      END DO
      END DO

! CAL. BGEFV
      CALL PAR_BGE_PAR_FV(PROPS, DEFGRD, DEFGRDV, DIR, BGEFV)

! ASSIGN VALUES
      DO I = 1,3
      DO ALPHA = 1,3
      DO A = 1,3
      DO M = 1,3
      TEM1(I,ALPHA,A) = TEM1(I,ALPHA,A) + BGEFV(I,M,ALPHA,A)*DIR(M)
      END DO
      END DO
      END DO
      END DO

! ASSIGN VALUES FOR TEM2
      DO I = 1,3
      DO ALPHA = 1,3
      DO A = 1,3
      DO P = 1,3
      DO Q = 1,3
      TEM2(I,ALPHA,A) = TEM2(I,ALPHA,A) + 
     +		DIR(P)*DIR(Q)*DIR(I)*BGEFV(P,Q,ALPHA,A)
      END DO
      END DO
      END DO
      END DO
      END DO

! CALCULATE MNEQ, MNEQDFV
      MUNEQ = PROPS(4)
      ORDPARA = PROPS(1)
      LOCKLIM = PROPS(2)
      MNEQ = -MUNEQ*3*ORDPARA/(1 - ORDPARA)/(1 + 2*ORDPARA)
      MNEQDFV = MNEQ*LOCKLIM/(LOCKLIM - (ELAIE - 3))**2*TEM0 + 
     +		MNEQ*LOCKLIM/(LOCKLIM - (ELAIE - 3))*(TEM1 - TEM2)

! CALCULATE STRESS AND ETAD
      CALL SIGMA(PROPS, DEFGRD_N, DEFGRDV_N, DIR_N, STRESS)
      CALL FETAD(PROPS, STRESS, ETAD)
      CALL DET(DEFGRD,JCB)

      RESOUT = DELTAT/ETAD/JCB*MNEQDFV

      RETURN
      END SUBROUTINE

      SUBROUTINE PAR_G_PAR_F(PROPS, DEFGRD, DEFGRDV, DIR,DELTAT, RESOUT)
! CALCLUATE TAGENT g TO F
      IMPLICIT NONE
      REAL*8 PROPS(12), DEFGRD(3,3), DEFGRDV(3,3),DIR(3),RESOUT(3,3,3,3)
      REAL*8 DEFGRDE(3,3), SHATEN(3,3), SHATEN0(3,3), ELAB(3,3), 
     +	ELABE(3,3), ELAI, ELAIE, SHATEN_INV(3,3), DEFGRDV_INV(3,3)
      REAL*8 INEF(3,3), TEM1(3,3), TEM2(3,3,3,3), FEF(3,3,3,3), 
     +	TEM3(3,3,3,3)
      REAL*8 MUNEQ, DELTAT, ETAN, LOCKLIM
      INTEGER M, ALPHA, I, A, N, BETA, KSI

! CALCULATE LOCAL VARIABLES
      CALL CAL_SHAPETENSOR(PROPS, DIR, SHATEN, SHATEN0)
      CALL CAL_ELAB(PROPS, DEFGRD, DEFGRDV, DIR, ELAB, ELABE)
      CALL CAL_ELAI(PROPS, DEFGRD, DEFGRDV, DIR, ELAI, ELAIE)
      CALL CAL_DEFGRDE(DEFGRD, DEFGRDV, DEFGRDE)
      CALL MATINV3D(SHATEN, SHATEN_INV)
      CALL MATINV3D(DEFGRDV, DEFGRDV_INV)
      CALL PAR_INE_PAR_F(PROPS, DEFGRD, DEFGRDV, DIR, INEF)
      CALL PAR_FE_PAR_F(DEFGRDV, FEF)

! INITIALIZE TEM1
      DO I = 1,3
      DO A = 1,3
      TEM1(I,A) = 0.
      END DO
      END DO

! INITIALIZE TEM2, TEM3
      DO ALPHA = 1,3
      DO BETA = 1,3
      DO I = 1,3
      DO A = 1,3
      TEM2(ALPHA,BETA,I,A) = 0.
      TEM3(ALPHA,BETA,I,A) = 0.
      END DO
      END DO
      END DO
      END DO

! ASSIGN VALUES
      DO M = 1,3
      DO ALPHA = 1,3
      DO N = 1,3
      DO KSI = 1,3
      DO BETA = 1,3
      TEM1(ALPHA,BETA) = TEM1(ALPHA,BETA) + DEFGRDE(M,ALPHA)*
     +		SHATEN_INV(M,N)*DEFGRDE(N,KSI)*SHATEN0(KSI,BETA)
      END DO
      END DO
      END DO
      END DO
      END DO

! ASSIGN VALUES FOR TEM2
      DO ALPHA = 1,3
      DO BETA = 1,3
      DO I = 1,3
      DO A = 1,3
      TEM2(ALPHA,BETA,I,A) = INEF(I,A)*TEM1(ALPHA,BETA)
      END DO
      END DO
      END DO
      END DO

! ASSIGN VALUES FOR TEM3
      DO M = 1,3
      DO ALPHA = 1,3
      DO I = 1,3
      DO A = 1,3
      DO N = 1,3
      DO BETA = 1,3
      DO KSI = 1,3
      TEM3(ALPHA,BETA,I,A) = TEM3(ALPHA,BETA,I,A) + 
     +    SHATEN_INV(M,N)*SHATEN0(KSI,BETA)* 
     +   (FEF(M,ALPHA,I,A)*DEFGRDE(N,KSI) + 
     +	DEFGRDE(M,ALPHA)*FEF(N,KSI,I,A))
      END DO
      END DO
      END DO
      END DO
      END DO
      END DO
      END DO

! ASSIGN MATERIAL PARAMETERS
      LOCKLIM = PROPS(2)
      MUNEQ = PROPS(4)
      ETAN = PROPS(6)
      RESOUT = - MUNEQ*DELTAT/ETAN*LOCKLIM/(LOCKLIM - (ELAIE - 3))**2*
     +		(TEM2 + (LOCKLIM - (ELAIE - 3))*TEM3)
      RETURN
      END SUBROUTINE

      SUBROUTINE PAR_G_PAR_FV(PROPS, DEFGRDV_N, DEFGRD, DEFGRDV, 
     +		DIR, DELTAT, RESOUT)
! CALCULATE TAGENT g TO Fv
      IMPLICIT NONE
      REAL*8 PROPS(12), DEFGRDV_N(3,3), DEFGRD(3,3), DEFGRDV(3,3), 
     +	 DIR(3), RESOUT(3,3,3,3)
      REAL*8 DEFGRDE(3,3), SHATEN(3,3), SHATEN0(3,3), 
     +	SHATEN_INV(3,3), IFVFV(3,3,3,3), TEM1(3,3,3,3)
      REAL*8 ELAB(3,3), ELABE(3,3), ELAI, ELAIE
      REAL*8 INEFV(3,3), FEFV(3,3,3,3), TEM2(3,3,3,3), TEM3(3,3,3,3)
      REAL*8 MUNEQ, DELTAT, ETAN, LOCKLIM
      INTEGER ALPHA, BETA, GAMMAITER, B, M, N, KSI, A

! CALCULATE LOCAL VARIABLES
      CALL CAL_SHAPETENSOR(PROPS, DIR, SHATEN, SHATEN0)
      CALL CAL_ELAB(PROPS, DEFGRD, DEFGRDV, DIR, ELAB, ELABE)
      CALL CAL_ELAI(PROPS, DEFGRD, DEFGRDV, DIR, ELAI, ELAIE)
      CALL CAL_DEFGRDE(DEFGRD, DEFGRDV, DEFGRDE)
      CALL MATINV3D(SHATEN, SHATEN_INV)
      CALL PAR_IF_PAR_F(DEFGRDV, IFVFV)
      CALL PAR_INE_PAR_FV(PROPS, DEFGRD, DEFGRDV, DIR, INEFV)
      CALL PAR_FE_PAR_FV(DEFGRD, DEFGRDV, FEFV)

! INITIALIZE TEM1, TEM2, TEM3
      DO ALPHA = 1,3
      DO BETA = 1,3
      DO GAMMAITER = 1,3
      DO B = 1,3
      TEM1(ALPHA,BETA,GAMMAITER,B) = 0.
      TEM2(ALPHA,BETA,GAMMAITER,B) = 0.
      TEM3(ALPHA,BETA,GAMMAITER,B) = 0.
      END DO
      END DO
      END DO
      END DO

! ASSIGN VALUES FOR TEM1
      DO ALPHA = 1,3
      DO BETA = 1,3
      DO A = 1,3
      DO GAMMAITER = 1,3
      DO B = 1,3
      TEM1(ALPHA,BETA,GAMMAITER,B) = TEM1(ALPHA,BETA,GAMMAITER,B) +
     +		DEFGRDV_N(ALPHA,A)*IFVFV(A,BETA,GAMMAITER,B)
      END DO
      END DO
      END DO
      END DO
      END DO

! ASSIGN VALUES FOR TEM2, TEM3
      DO ALPHA = 1,3
      DO BETA = 1,3
      DO GAMMAITER = 1,3
      DO B = 1,3
      DO M = 1,3
      DO N = 1,3
      DO KSI = 1,3
      TEM2(ALPHA,BETA,GAMMAITER,B) = TEM2(ALPHA,BETA,GAMMAITER,B) +
     + INEFV(GAMMAITER,B)*DEFGRDE(M,ALPHA)*
     + SHATEN_INV(M,N)*DEFGRDE(N,BETA)
      TEM3(ALPHA,BETA,GAMMAITER,B) = TEM3(ALPHA,BETA,GAMMAITER,B) +
     + SHATEN_INV(M,N)*SHATEN0(KSI,BETA)*(FEFV(M,ALPHA,GAMMAITER,B)
     + *DEFGRDE(N,KSI) + 
     + FEFV(N,KSI,GAMMAITER,B)*DEFGRDE(M,ALPHA))
      END DO
      END DO
      END DO
      END DO
      END DO
      END DO
      END DO

! ASSIGN MATER PARAMETERS
      LOCKLIM = PROPS(2)
      MUNEQ = PROPS(4)
      ETAN = PROPS(6)

      RESOUT = -TEM1 - MUNEQ*DELTAT/ETAN*LOCKLIM/(LOCKLIM-(ELAIE-3))**2
     +		*(TEM2+(LOCKLIM-(ELAIE-3))*TEM3)
      RETURN
      END SUBROUTINE

      SUBROUTINE PAR_G_PAR_D(PROPS, DEFGRD, DEFGRDV, DIR, DELTAT,RESOUT)
! CALCLUAT TAGENT g TP d
      IMPLICIT NONE
      REAL*8 PROPS(12), DEFGRD(3,3), DEFGRDV(3,3), DIR(3), RESOUT(3,3,3)
      REAL*8 DEFGRDE(3,3), SHATEN(3,3), SHATEN0(3,3), SHATEN_INV(3,3)
      REAL*8 ELAB(3,3), ELABE(3,3), ELAI, ELAIE
      REAL*8 TEM1(3,3), INED(3), TEM2(3,3,3), TEM3(3,3,3), ILD(3,3,3)
      REAL*8 MUNEQ, DELTAT, ETAN, LOCKLIM
      INTEGER ALPHA, BETA, M, N, KSI, K

! CALCULATE LOCAL VARIABLES
      CALL CAL_DEFGRDE(DEFGRD, DEFGRDV, DEFGRDE)
      CALL CAL_SHAPETENSOR(PROPS, DIR, SHATEN, SHATEN0)
      CALL CAL_ELAB(PROPS, DEFGRD, DEFGRDV, DIR, ELAB, ELABE)
      CALL CAL_ELAI(PROPS, DEFGRD, DEFGRDV, DIR, ELAI, ELAIE)
      CALL PAR_INE_PAR_D(PROPS, DEFGRD, DEFGRDV, DIR, INED)
      CALL PAR_IL_PAR_D(PROPS, DIR, ILD)
      CALL MATINV3D(SHATEN, SHATEN_INV)

! INITIALIZE TEM1
      DO ALPHA = 1,3
      DO BETA = 1,3
      TEM1(ALPHA,BETA) = 0.
      END DO
      END DO

! INITIALIZE TEM2, TEM3
      DO ALPHA = 1,3
      DO BETA = 1,3
      DO K = 1,3
      TEM2(ALPHA,BETA,K) = 0.
      TEM3(ALPHA,BETA,K) = 0.
      END DO
      END DO
      END DO

! ASSIGN VALUES FOR TEM1
      DO ALPHA = 1,3
      DO BETA = 1,3
      DO M = 1,3
      DO N = 1,3
      DO KSI = 1,3
      TEM1(ALPHA,BETA) = TEM1(ALPHA,BETA) + DEFGRDE(M,ALPHA)*
     +	SHATEN_INV(M,N)*DEFGRDE(N,KSI)*SHATEN0(KSI,BETA)
      END DO
      END DO
      END DO
      END DO
      END DO

! ASSIGN VALUES FOR TEM2
      DO ALPHA = 1,3
      DO BETA = 1,3
      DO K = 1,3
      TEM2(ALPHA,BETA,K) = INED(K)*TEM1(ALPHA,BETA)
      END DO
      END DO
      END DO

! ASSIGN VALUES FFOR TEM3
      DO ALPHA = 1,3
      DO BETA = 1,3
      DO M = 1,3
      DO N = 1,3
      DO KSI = 1,3
      DO K = 1,3
            TEM3(ALPHA,BETA,K) = TEM3(ALPHA,BETA,K) + 
     +		DEFGRDE(M,ALPHA)*DEFGRDE(N,KSI)*SHATEN0(KSI,BETA)*ILD(M,N,K)
      END DO
      END DO
      END DO
      END DO
      END DO
      END DO

! ASSIGN MATERIAL PARAMETERS
      LOCKLIM = PROPS(2)
      MUNEQ = PROPS(4)
      ETAN = PROPS(6)

      RESOUT = -MUNEQ*DELTAT/ETAN*(LOCKLIM/(LOCKLIM-(ELAIE-3))**2*TEM2+
     +     LOCKLIM/(LOCKLIM-(ELAIE-3))*TEM3)
      RETURN
      END SUBROUTINE

      SUBROUTINE PAR_SIGMA_PAR_D(PROPS, DEFGRD, DEFGRDV, DIR, RESOUT)
! CALCULATE REAL TANGENT 
      IMPLICIT NONE
      REAL*8 PROPS(12), DEFGRD(3,3), DEFGRDV(3,3), DIR(3), RESOUT(3,3,3)
      REAL*8 JCB, DSDD(3,3,3)
      
      CALL PAR_SIGMABAR_PAR_D(PROPS, DEFGRD, DEFGRDV, DIR, DSDD)
      CALL DET(DEFGRD, JCB)
      
      RESOUT = DSDD/JCB
      
      RETURN
      END SUBROUTINE
      
      SUBROUTINE PAR_SIGMABAR_PAR_D(PROPS, DEFGRD, DEFGRDV, DIR, RESOUT)
! CALCULATE TAGENT SIGMA TO d
      IMPLICIT NONE
      REAL*8 PROPS(12), DEFGRD(3,3), DEFGRDV(3,3), DIR(3)
      REAL*8 DEFGRDE(3,3), SHATEN(3,3), SHATEN0(3,3), ELAI, ELAIE, 
     +       ELAB(3,3), ELABE(3,3), KCRON(3,3)
      REAL*8 TEM1(3), TEM1E(3), TEM2(3,3), TEM2E(3,3), TEM3(3,3,3), 
     +	TEM3E(3,3,3), KTEM(3,3,3), KTEME(3,3,3)
      REAL*8 MUEQ, MUNEQ, ORDPARA, LOCKLIM, LPA, LPER, DSEQDD(3,3,3), 
     +	 DSNEQDD(3,3,3), RESOUT(3,3,3)
      INTEGER A, B, K, I, J, M

! CALCULATE RELATIVE VARIABLES IN SOFT-ELASTICITY
      CALL CAL_ELAI(PROPS, DEFGRD, DEFGRDV, DIR, ELAI, ELAIE)
      CALL CAL_ELAB(PROPS, DEFGRD, DEFGRDV, DIR, ELAB, ELABE)
      CALL CAL_SHAPETENSOR(PROPS, DIR, SHATEN, SHATEN0)
      CALL CAL_DEFGRDE(DEFGRD, DEFGRDV, DEFGRDE)
      CALL IDGENERATION(KCRON)

! ASSIGN MATERIAL PARAMETERS
      ORDPARA = PROPS(1)
      LPA = 1 + 2.*ORDPARA
      LPER = 1 - ORDPARA
      LOCKLIM = PROPS(2)
      MUEQ = PROPS(3)
      MUNEQ = PROPS(4)

! INITIALIZE TEM1, TEM1E
      DO K = 1,3
      TEM1(K) = 0.
      TEM1E(K) = 0.
      END DO

! INITIALIZE TEM2, TEM2E
      DO I = 1,3
      DO J = 1,3
      TEM2(I,J) = 0.
      TEM2E(I,J) = 0.
      END DO
      END DO

! INITIALIZE TEM3, TEM3E, KTEM, KTEME, DSEQDD, DSNEQDD
      DO I = 1,3
      DO J = 1,3
      DO K = 1,3
      TEM3(I,J,K) = 0.
      TEM3E(I,J,K) = 0.
      KTEM(I,J,K) = 0.
      KTEME(I,J,K) = 0.
      DSEQDD(I,J,K) = 0.
      DSNEQDD(I,J,K) = 0.
      END DO
      END DO
      END DO

! ASSIGN VALUES FOR TEM1, TEM1E
      DO A = 1,3
      DO B = 1,3
      DO K = 1,3
      DO M = 1,3
      TEM1(K) = TEM1(K) + 2*(1/LPA - 1/LPER)*SHATEN0(A,B)*DEFGRD(K,A)*
     +	 DEFGRD(M,B)*DIR(M)
      TEM1E(K) = TEM1E(K) + 2*(1/LPA - 1/LPER)*SHATEN0(A,B)*
     +	 DEFGRDE(K,A)*DEFGRDE(M,B)*DIR(M)
      END DO
      END DO
      END DO
      END DO

! ASSIGN VALUES FOR TEM2, TEM2E
      DO I = 1,3
      DO J = 1,3
      DO M = 1,3
      TEM2(I,J) = TEM2(I,J) - 3*ORDPARA/2/(1+2*ORDPARA)*(DIR(I)*
     +		 DIR(M)*ELAB(J,M)+DIR(M)*DIR(J)*ELAB(I,M))
      TEM2E(I,J) = TEM2E(I,J) - 3*ORDPARA/2/(1+2*ORDPARA)*(DIR(I)*
     +		DIR(M)*ELABE(J,M)+DIR(M)*DIR(J)*ELABE(I,M))
      END DO
      END DO
      END DO
      TEM2 = TEM2 + ELAB
      TEM2E = TEM2E + ELABE

! ASSIGN VALUES FOR TEM3, TEM3E
      DO I = 1,3
      DO J = 1,3
      DO K = 1,3
      DO M = 1,3
      TEM3(I,J,K) = TEM3(I,J,K) + KCRON(I,K)*ELAB(J,M)*DIR(M) + 
     +		 DIR(I)*ELAB(J,M)*KCRON(M,K) + ELAB(I,M)*KCRON(M,K)*DIR(J) + 
     +		 ELAB(I,M)*DIR(M)*KCRON(J,K)
      TEM3E(I,J,K) = TEM3E(I,J,K) + KCRON(I,K)*ELABE(J,M)*DIR(M) + 
     +	DIR(I)*ELABE(J,M)*KCRON(M,K) + ELABE(I,M)*KCRON(M,K)*DIR(J) + 
     +	 ELABE(I,M)*DIR(M)*KCRON(J,K)
      END DO
      END DO
      END DO
      END DO

! ASSIGN VALUES FOR KTEM, KTEME
      DO I = 1,3
      DO J = 1,3
      DO K = 1,3
      KTEM(I,J,K) = TEM1(K)*TEM2(I,J)
      KTEME(I,J,K) = TEM1E(K)*TEM2E(I,J)
      END DO
      END DO
      END DO

! CALCULATE DSEQDD, DSNEQDD
      DSEQDD = MUEQ/(1-ORDPARA)*LOCKLIM/(LOCKLIM-(ELAI-3))*
     +	 (1/(LOCKLIM-(ELAI-3))*KTEM-3*ORDPARA/2/(1+2*ORDPARA)*TEM3)
      DSNEQDD = MUNEQ/(1-ORDPARA)*LOCKLIM/(LOCKLIM-(ELAIE-3))*
     +	(1/(LOCKLIM-(ELAIE-3))*KTEME-3*ORDPARA/2/(1+2*ORDPARA)*TEM3E)
      RESOUT = DSEQDD + DSNEQDD
      RETURN
      END SUBROUTINE

      SUBROUTINE PAR_SIGMA_PAR_F(PROPS, DEFGRD, DEFGRDV, DIR, RESOUT)
! REAL TANGENTS
      IMPLICIT NONE
      REAL*8 PROPS(12), DEFGRD(3,3), DEFGRDV(3,3), DIR(3)
      REAL*8 DSDF(3,3,3,3), JCB, JF(3,3), RESOUT(3,3,3,3), SIGBAR(3,3)
      INTEGER I, J, K, A
      
      CALL PAR_SIGMABAR_PAR_F(PROPS, DEFGRD, DEFGRDV, DIR, DSDF)
      CALL SIGMA_BAR(PROPS, DEFGRD, DEFGRDV, DIR, SIGBAR)
      CALL DET(DEFGRD, JCB)
      CALL PAR_JCB_PAR_F(DEFGRD, JF)

! CALCULATE JF O SIGMA
      RESOUT = 0.
      DO I = 1,3
          DO J = 1,3
              DO K = 1,3
                  DO A = 1,3
                      RESOUT(I,J,K,A) = SIGBAR(I,J)*JF(K,A)
                  END DO
              END DO
          END DO
      END DO
      
      RESOUT = -1./JCB**2*RESOUT + 1./JCB*DSDF
      
      RETURN
      END SUBROUTINE

      
      SUBROUTINE PAR_SIGMABAR_PAR_F(PROPS, DEFGRD, DEFGRDV, DIR, RESOUT)
! CALCULATE TAGENT SIGMA TO F
      IMPLICIT NONE
      REAL*8 PROPS(12), DEFGRD(3,3), DEFGRDV(3,3), DIR(3)
      REAL*8 DEFGRDE(3,3), ELAI, ELAIE, ELAB(3,3), ELABE(3,3)
      REAL*8 INF(3,3), INEF(3,3), TEM0(3,3), TEM0E(3,3), 
     +	 TEM1(3,3,3,3), TEM1E(3,3,3,3)
      REAL*8 BGF(3,3,3,3), BGEF(3,3,3,3), TEM2(3,3,3,3), TEM2E(3,3,3,3)
      REAL*8 BGD(3), BGED(3), DBGD, DBGED, SHATEN(3,3), SHATEN0(3,3)
      REAL*8 JCB, DEFGRD_INV(3,3), TEMP(3,3,3,3), SEQF(3,3,3,3), 
     +	 SNEQF(3,3,3,3), RESOUT(3,3,3,3)
      REAL*8 MUEQ, MUNEQ, ORDPARA, LOCKLIM, BULKPENALTY, KCRON(3,3)
      INTEGER I, J, K, A, M

! ASSIGN MATERIAL PARAMETERS
      ORDPARA = PROPS(1)
      LOCKLIM = PROPS(2)
      MUEQ = PROPS(3)
      MUNEQ = PROPS(4)
      BULKPENALTY = PROPS(11)
      CALL IDGENERATION(KCRON)

! CALCULATE RELATIVE VARIABLES IN SOFT-ELASTICITY
      CALL CAL_ELAI(PROPS, DEFGRD, DEFGRDV, DIR, ELAI, ELAIE)
      CALL CAL_ELAB(PROPS, DEFGRD, DEFGRDV, DIR, ELAB, ELABE)
      CALL CAL_SHAPETENSOR(PROPS, DIR, SHATEN, SHATEN0)
      CALL CAL_DEFGRDE(DEFGRD, DEFGRDV, DEFGRDE)

! CALCULATE MIDDLE DERIVATIVES
      CALL PAR_IN_PAR_F(PROPS, DEFGRD, DIR, INF)
      CALL PAR_INE_PAR_F(PROPS, DEFGRD, DEFGRDV, DIR, INEF)
      CALL CAL_BGD(PROPS, DEFGRD, DEFGRDV, DIR, BGD, BGED, DBGD, DBGED)
      CALL PAR_BG_PAR_F(PROPS, DEFGRD, DEFGRDV, DIR, BGF)
      CALL PAR_BGE_PAR_F(PROPS, DEFGRD, DEFGRDV, DIR, BGEF)

! CALCULATE TEM0 AND TEM0E
      DO I = 1,3
      DO J = 1,3
      TEM0(I,J) = DIR(I)*BGD(J) + BGD(I)*DIR(J)
      TEM0E(I,J) = DIR(I)*BGED(J) + BGED(I)*DIR(J)
      END DO
      END DO

! INITIALIZE TEM1, TEM1E, TEM2, TEM2E, TEMP
      DO I = 1,3
      DO J = 1,3
      DO K = 1,3
      DO A = 1,3
      TEM1(I,J,K,A) = 0.
      TEM1E(I,J,K,A) = 0.
      TEM2(I,J,K,A) = 0.
      TEM2E(I,J,K,A) = 0.
      TEMP(I,J,K,A) = 0.
      END DO
      END DO
      END DO
      END DO

! CALCULATE TEM1, TEM1E
      DO I = 1,3
      DO J = 1,3
      DO K = 1,3
      DO A = 1,3
      TEM1(I,J,K,A) = INF(K,A)*(ELAB(I,J)-3*ORDPARA/2/
     + (1+2*ORDPARA)*TEM0(I,J))
      TEM1E(I,J,K,A) = INEF(K,A)*(ELABE(I,J)-3*ORDPARA/2/
     + (1+2*ORDPARA)*TEM0E(I,J))
      END DO
      END DO
      END DO
      END DO

! CALCULATE TEM2, TEM2E
      DO I = 1,3
      DO J = 1,3
      DO K = 1,3
      DO A = 1,3
      DO M = 1,3
      TEM2(I,J,K,A) = TEM2(I,J,K,A) + DIR(I)*BGF(J,M,K,A)*DIR(M) 
     + + BGF(I,M,K,A)*DIR(M)*DIR(J)
      TEM2E(I,J,K,A) = TEM2E(I,J,K,A) + DIR(I)*BGEF(J,M,K,A)*DIR(M) 
     + + BGEF(I,M,K,A)*DIR(M)*DIR(J)
      END DO
      END DO
      END DO
      END DO
      END DO

      TEM2 = BGF - 3*ORDPARA/2/(1+2*ORDPARA)*TEM2
      TEM2E = BGEF - 3*ORDPARA/2/(1+2*ORDPARA)*TEM2E

      CALL DET(DEFGRD, JCB)
      CALL MATINV3D(DEFGRD, DEFGRD_INV)

! CALCULATE TEMP
      DO I = 1,3
      DO J = 1,3
      DO K = 1,3
      DO A = 1,3
      TEMP(I,J,K,A) = - BULKPENALTY*JCB*DEFGRD_INV(A,K)*KCRON(I,J)
c       TEMP(I,J,K,A) = - BULKPENALTY*(JCB+1./JCB)
c     +                 *DEFGRD_INV(A,K)*KCRON(I,J)
      END DO
      END DO
      END DO
      END DO

      SEQF = MUEQ/(1-ORDPARA)*LOCKLIM/(LOCKLIM-(ELAI-3))**2*
     + (TEM1+(LOCKLIM-(ELAI-3))*TEM2)-TEMP
      SNEQF = MUNEQ/(1-ORDPARA)*LOCKLIM/(LOCKLIM-(ELAIE-3))**2*
     + (TEM1E+(LOCKLIM-(ELAIE-3))*TEM2E)
      RESOUT = SEQF + SNEQF
      RETURN
      END SUBROUTINE

      SUBROUTINE PAR_SIGMA_PAR_FV(PROPS, DEFGRD, DEFGRDV, DIR, RESOUT)
! CALCULATE REAL TANGENT
      IMPLICIT NONE
      REAL*8 PROPS(12), DEFGRD(3,3), DEFGRDV(3,3), DIR(3)
      REAL*8 RESOUT(3,3,3,3), DSDFV(3,3,3,3), JCB
      
      CALL DET(DEFGRD, JCB)
      CALL PAR_SIGMABAR_PAR_FV(PROPS, DEFGRD, DEFGRDV, DIR, DSDFV)
      
      RESOUT = DSDFV/JCB
      
      RETURN
      END SUBROUTINE

      SUBROUTINE PAR_SIGMABAR_PAR_FV(PROPS, DEFGRD, DEFGRDV, 
     +                               DIR, RESOUT)
! CALCULATE TAGENT SIGMA TO Fv
      IMPLICIT NONE
      REAL*8 PROPS(12), DEFGRD(3,3),DEFGRDV(3,3),DIR(3),RESOUT(3,3,3,3)
      REAL*8 DEFGRDE(3,3), ELAB(3,3), ELABE(3,3), ELAI, ELAIE, 
     + SHATEN(3,3), SHATEN0(3,3)
      REAL*8 TEM0(3,3), INEFV(3,3), TEM1(3,3,3,3), BGEFV(3,3,3,3), 
     + TEM2(3,3,3,3)
      REAL*8 ORDPARA, LOCKLIM, MUNEQ
      INTEGER I, J, M, ALPHA, A, K

! ASSIGN MATERIAL PARAMETERS
      ORDPARA = PROPS(1)
      LOCKLIM = PROPS(2)
      MUNEQ = PROPS(4)

! CALCULATE RELATIVE VARIABLES IN SOFT ELASTICITY
      CALL CAL_ELAI(PROPS, DEFGRD, DEFGRDV, DIR, ELAI, ELAIE)
      CALL CAL_ELAB(PROPS, DEFGRD, DEFGRDV, DIR, ELAB, ELABE)
      CALL CAL_SHAPETENSOR(PROPS, DIR, SHATEN, SHATEN0)
      CALL CAL_DEFGRDE(DEFGRD, DEFGRDV, DEFGRDE)

! CALCULATE DERIVATIEVS
      CALL PAR_INE_PAR_FV(PROPS, DEFGRD, DEFGRDV, DIR, INEFV)
      CALL PAR_BGE_PAR_FV(PROPS, DEFGRD, DEFGRDV, DIR, BGEFV)

! INITIALIZE TEM0
      DO I = 1,3
      DO J = 1,3
      TEM0(I,J) = 0.
      END DO
      END DO

      ! CALCULATE TEM0
      DO I = 1,3
      DO J = 1,3
      DO M = 1,3
      TEM0(I,J) = TEM0(I,J) + DIR(I)*ELABE(J,M)*DIR(M) + 
     + ELABE(I,M)*DIR(M)*DIR(J)
      END DO
      END DO
      END DO

! INITIALIZE TEM1, TEM2
      DO I = 1,3
      DO J = 1,3
      DO K = 1,3
      DO A = 1,3
      TEM1(I,J,K,A) = 0.
      TEM2(I,J,K,A) = 0.
      END DO
      END DO
      END DO
      END DO

      ! CALCULATE TEM1
      DO I = 1,3
      DO J = 1,3
      DO ALPHA = 1,3
      DO A = 1,3
      TEM1(I,J,ALPHA,A) = INEFV(ALPHA,A)*(ELABE(I,J)- 3*ORDPARA/2/
     + (1+2*ORDPARA)*TEM0(I,J))
      END DO
      END DO
      END DO
      END DO

! CALCULATE TEM2
      DO I = 1,3
      DO J = 1,3
      DO ALPHA = 1,3
      DO A = 1,3
      DO M = 1,3
      TEM2(I,J,ALPHA,A) = TEM2(I,J,ALPHA,A) + 
     + DIR(I)*DIR(M)*BGEFV(J,M,ALPHA,A) + 
     + DIR(M)*DIR(J)*BGEFV(I,M,ALPHA,A)
      END DO
      END DO
      END DO
      END DO
      END DO
      TEM2 = BGEFV - 3*ORDPARA/2/(1+2*ORDPARA)*TEM2
      RESOUT = MUNEQ/(1-ORDPARA)*LOCKLIM/(LOCKLIM-(ELAIE-3))*
     + (1/(LOCKLIM-(ELAIE-3))*TEM1+TEM2)
      RETURN
      END SUBROUTINE

      SUBROUTINE PAR_P_PAR_D(PROPS, DEFGRD, DEFGRDV, DIR, RESOUT)
! CALCULATE TAGENT P TO d
      IMPLICIT NONE
      REAL*8 PROPS(12), DEFGRD(3,3), DEFGRDV(3,3), DIR(3), RESOUT(3,3,3)
      REAL*8 JCB, PSPD(3,3,3), DEFGRD_INV(3,3), TEM(3,3,3)
      INTEGER I, M, A, K

      CALL PAR_SIGMA_PAR_D(PROPS, DEFGRD, DEFGRDV, DIR, PSPD)
      CALL DET(DEFGRD, JCB)
      CALL MATINV3D(DEFGRD, DEFGRD_INV)

! INITIALIZE TEM
      DO I = 1,3
      DO A = 1,3
      DO K = 1,3
      TEM(I,A,K) = 0.
      END DO
      END DO
      END DO

! CALCULATE TEM
      DO I = 1,3
      DO M = 1,3
      DO A = 1,3
      DO K = 1,3
      TEM(I,A,K) = TEM(I,A,K) + JCB*PSPD(I,M,K)*DEFGRD_INV(A,M)
      END DO
      END DO
      END DO
      END DO
      RESOUT = TEM
      RETURN
      END SUBROUTINE

      SUBROUTINE PAR_P_PAR_FV(PROPS, DEFGRD, DEFGRDV, DIR, RESOUT)
      ! CALCULATE TAGENT P TO Fv
      IMPLICIT NONE
      REAL*8 PROPS(12), DEFGRD(3,3), DEFGRDV(3,3),DIR(3),RESOUT(3,3,3,3)
      REAL*8 JCB, DEFGRD_INV(3,3), DSDFV(3,3,3,3), TEM(3,3,3,3)
      INTEGER I, M, ALPHA, B, A

      CALL DET(DEFGRD, JCB)
      CALL MATINV3D(DEFGRD, DEFGRD_INV)
      CALL PAR_SIGMA_PAR_FV(PROPS, DEFGRD, DEFGRDV, DIR, DSDFV)

! INITIALIZE TEM
      DO I = 1,3
      DO A = 1,3
      DO ALPHA = 1,3
      DO B = 1,3
      TEM(I,A,ALPHA,B) = 0.
      END DO
      END DO
      END DO
      END DO

! CALCULATE TEM
      DO I = 1,3
      DO M = 1,3
      DO ALPHA = 1,3
      DO B = 1,3
      DO A = 1,3
      TEM(I,A,ALPHA,B) = TEM(I,A,ALPHA,B) + JCB*DSDFV(I,M,ALPHA,B)*
     + DEFGRD_INV(A,M)
      END DO
      END DO
      END DO
      END DO
      END DO
      RESOUT = TEM
      RETURN
      END SUBROUTINE

      SUBROUTINE PAR_P_PAR_F(PROPS, DEFGRD, DEFGRDV, DIR, RESOUT)
! CALCULATE TAGENT P TO F
      IMPLICIT NONE
      REAL*8 PROPS(12), DEFGRD(3,3), DEFGRDV(3,3),DIR(3),RESOUT(3,3,3,3)
      REAL*8 JCB, DEFGRD_INV(3,3), SIGMAF(3,3,3,3), IFF(3,3,3,3)
      REAL*8 TEM1(3,3,3,3), TEM2(3,3,3,3), TEM3(3,3,3,3), STRESS(3,3)
      INTEGER I, J, A, B, M

      CALL DET(DEFGRD, JCB)
      CALL MATINV3D(DEFGRD, DEFGRD_INV)
      CALL PAR_SIGMA_PAR_F(PROPS, DEFGRD, DEFGRDV, DIR, SIGMAF)
      CALL PAR_IF_PAR_F(DEFGRD, IFF)
      CALL SIGMA(PROPS, DEFGRD, DEFGRDV, DIR, STRESS)

! INITIALIZE TEM1, TEM2, TEM3
      DO I = 1,3
      DO J = 1,3
      DO A = 1,3
      DO B = 1,3
      TEM1(I,J,A,B) = 0.
      TEM2(I,J,A,B) = 0.
      TEM3(I,J,A,B) = 0.
      END DO
      END DO
      END DO
      END DO

! CALCULATE TEM1, TEM2, TEM3
      DO I = 1,3
      DO J = 1,3
      DO A = 1,3
      DO B = 1,3
      DO M = 1,3
      TEM1(I,A,J,B) = TEM1(I,A,J,B) + JCB*DEFGRD_INV(B,J)*
     + STRESS(I,M)*DEFGRD_INV(A,M)
      TEM2(I,A,J,B) = TEM2(I,A,J,B)+JCB*SIGMAF(I,M,J,B)*DEFGRD_INV(A,M)
      TEM3(I,A,J,B) = TEM3(I,A,J,B) + JCB*STRESS(I,M)*IFF(A,M,J,B)
      END DO
      END DO
      END DO
      END DO
      END DO
      RESOUT = TEM1 + TEM2 + TEM3
      RETURN
      END SUBROUTINE

      SUBROUTINE KFV(PROPS, DEFGRD_N, DEFGRDV_N, DIR_N, DEFGRD, 
     + DEFGRDV, DIR, DELTAT, RESOUT)
! CONVERT TENSOR PAR_F_PAR_FV TO MATRIX
      IMPLICIT NONE
      REAL*8 PROPS(12), DEFGRD_N(3,3), DEFGRDV_N(3,3), DIR_N(3), 
     + DEFGRD(3,3), DEFGRDV(3,3), DIR(3), DELTAT
      REAL*8 RESOUT(3,9), DFDFV(3,3,3)
      INTEGER I, ALPHA, BETA

      CALL PAR_F_PAR_FV(PROPS, DEFGRD_N, DEFGRDV_N, DIR_N, DEFGRD, 
     + DEFGRDV, DIR, DELTAT, DFDFV)
      DO I = 1,3
      DO ALPHA = 1,3
      DO BETA = 1,3
      RESOUT(I,3*(ALPHA-1)+BETA) = DFDFV(I,ALPHA,BETA)
      END DO
      END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE KGD(PROPS, DEFGRD, DEFGRDV, DIR, DELTAT, RESOUT)
! CONVERT TENSOR PAR_g_PAR_d TO MATRIX
      IMPLICIT NONE
      REAL*8 PROPS(12), DEFGRD(3,3), DEFGRDV(3,3), DIR(3), 
     + RESOUT(9,3), DELTAT
      REAL*8 DGDD(3,3,3)
      INTEGER ALPHA, BETA, K

      CALL PAR_G_PAR_D(PROPS, DEFGRD, DEFGRDV, DIR, DELTAT, DGDD)
      DO ALPHA = 1,3
      DO BETA = 1,3
      DO K = 1,3
      RESOUT(3*(ALPHA-1)+BETA,K) = DGDD(ALPHA,BETA,K)
      END DO
      END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE KGV(PROPS, DEFGRD_N, DEFGRDV_N, DIR_N, DEFGRD,
     + DEFGRDV, DIR, DELTAT, RESOUT)
! CONVERT TENSOR PAR_g_PAR_Fv TO MATRIX
      IMPLICIT NONE
      REAL*8 PROPS(12), DEFGRD_N(3,3), DEFGRDV_N(3,3), DIR_N(3), 
     + DEFGRD(3,3), DEFGRDV(3,3)
      REAL*8 DIR(3), DELTAT, RESOUT(9,9), DGDFV(3,3,3,3)
      INTEGER ALPHA, BETA, GAMMAITER, B

      CALL PAR_G_PAR_FV(PROPS, DEFGRDV_N, DEFGRD, DEFGRDV, 
     + DIR, DELTAT, DGDFV)
      DO ALPHA = 1,3
      DO BETA = 1,3
      DO GAMMAITER = 1,3
      DO B = 1,3
      RESOUT(3*(ALPHA-1)+BETA,3*(GAMMAITER-1)+B) = 
     + DGDFV(ALPHA,BETA,GAMMAITER,B)
      END DO
      END DO
      END DO
      END DO
      RETURN
      END SUBROUTINE

      SUBROUTINE STIFFNESSTOTAL(PROPS, DEFGRD_N, DEFGRDV_N, DIR_N, 
     + DEFGRD, DEFGRDV, DIR, DELTAT, RESOUT)
! THE TOTAL STIFFNESS MATRIX C_total, dP = C_total:dF
      IMPLICIT NONE
      REAL*8 PROPS(12), DEFGRD_N(3,3), DEFGRDV_N(3,3), DIR_N(3), 
     + DEFGRD(3,3), DEFGRDV(3,3), DIR(3), RESOUT(9,9)
      REAL*8 TEMFF(3,3,3), TEMGF(3,3,3,3), TEMFD(3,3), TEMFV(3,3,3), 
     + TEMGD(3,3,3), TEMGV(3,3,3,3), DELTAT
      REAL*8 KF(12,9), KQ(12,12), CQ(9,12), CF(9,9), TEMPD(3,3,3), 
     + TEMPV(3,3,3,3), TEMPF(3,3,3,3), IKQ(12,12)
      INTEGER I, J, K, L, ALPHA, A, BETA, GAMMAITER, B

! CALCULATE DERIVATIVES
      CALL PAR_F_PAR_F(PROPS, DEFGRD_N, DEFGRDV_N, DIR_N, DEFGRD, 
     + DEFGRDV, DIR, DELTAT, TEMFF)
      CALL PAR_G_PAR_F(PROPS, DEFGRD, DEFGRDV, DIR, DELTAT, TEMGF)
      CALL PAR_F_PAR_D(PROPS, DEFGRD_N, DEFGRDV_N, DIR_N, DEFGRD, 
     + DEFGRDV, DIR, DELTAT, TEMFD)
      CALL PAR_F_PAR_FV(PROPS, DEFGRD_N, DEFGRDV_N, DIR_N, DEFGRD, 
     + DEFGRDV, DIR, DELTAT, TEMFV)
      CALL PAR_G_PAR_D(PROPS, DEFGRD, DEFGRDV, DIR, DELTAT, TEMGD)
      CALL PAR_G_PAR_FV(PROPS, DEFGRDV_N, DEFGRD, DEFGRDV, DIR,
     + DELTAT, TEMGV)
      CALL PAR_P_PAR_D(PROPS, DEFGRD, DEFGRDV, DIR, TEMPD)
      CALL PAR_P_PAR_FV(PROPS, DEFGRD, DEFGRDV, DIR, TEMPV)
      CALL PAR_P_PAR_F(PROPS, DEFGRD, DEFGRDV, DIR, TEMPF)

! ASSIGN KF
      DO I = 1,3
      DO J = 1,3
      DO K = 1,3
      KF(I,3*(J-1)+K) = TEMFF(I,J,K)
      END DO
      END DO
      END DO

      DO I = 1,3
      DO J = 1,3
      DO K = 1,3
      DO L = 1,3
      KF(3*I+J,3*(K-1)+L) = TEMGF(I,J,K,L)
      END DO
      END DO
      END DO
      END DO

! ASSIGN KQ
      DO I = 1,3
      DO J = 1,3
      KQ(I,J) = TEMFD(I,J)
      END DO
      END DO

      DO I = 1,3
      DO ALPHA = 1,3
      DO A = 1,3
      KQ(I,3*ALPHA+A) = TEMFV(I,ALPHA,A)
      END DO
      END DO
      END DO

      DO ALPHA = 1,3
      DO BETA = 1,3
      DO K = 1,3
      KQ(3*ALPHA+BETA,K) = TEMGD(ALPHA,BETA,K)
      END DO
      END DO
      END DO

      DO ALPHA = 1,3
      DO BETA = 1,3
      DO GAMMAITER = 1,3
      DO B = 1,3
      KQ(3*ALPHA+BETA,3*GAMMAITER+B) = TEMGV(ALPHA,BETA,GAMMAITER,B)
      END DO
      END DO
      END DO
      END DO

! CALCULATE CQ
      DO I = 1,3
      DO A = 1,3
      DO K = 1,3
      CQ(3*(I-1)+A,K) = TEMPD(I,A,K)
      END DO
      END DO
      END DO

      DO I = 1,3
      DO A = 1,3
      DO ALPHA = 1,3
      DO B = 1,3
      CQ(3*(I-1)+A,3*ALPHA+B) = TEMPV(I,A,ALPHA,B)
      END DO
      END DO
      END DO
      END DO

! CALCULATE CF
      DO I = 1,3
      DO A = 1,3
      DO J = 1,3
      DO B = 1,3
      CF(3*(I-1)+A,3*(J-1)+B) = TEMPF(I,A,J,B)
      END DO
      END DO
      END DO
      END DO

      CALL MATINVMD(KQ, 12, IKQ)
      RESOUT = CF - MATMUL(CQ,MATMUL(IKQ,KF))
      RETURN
      END SUBROUTINE

      SUBROUTINE TANGENT_STRESS(PROPS, DEFGRD_N, DEFGRDV_N, DIR_N, 
     + DEFGRD, DEFGRDV, DIR, DELTAT, RESOUT)
! THE TOTAL STIFFNESS MATRIX C_total, dP = C_total:dF
      IMPLICIT NONE
      REAL*8 PROPS(12), DEFGRD_N(3,3), DEFGRDV_N(3,3), DIR_N(3), 
     + DEFGRD(3,3), DEFGRDV(3,3), DIR(3), RESOUT(9,9)
      REAL*8 TEMFF(3,3,3), TEMGF(3,3,3,3), TEMFD(3,3), TEMFV(3,3,3), 
     + TEMGD(3,3,3), TEMGV(3,3,3,3), DELTAT
      REAL*8 KF(12,9), KQ(12,12), CQ(9,12), CF(9,9), TEMPD(3,3,3), 
     + TEMPV(3,3,3,3), TEMPF(3,3,3,3), IKQ(12,12)
      REAL*8 KFD(3,3), KFF(3,9), KFV(3,9), KGD(9,3), KGF(9,9), 
     + KGV(9,9), KPD(9,3), KPF(9,9), KPV(9,9)
      INTEGER I, J, K, L, ALPHA, A, BETA, GAMMAITER, B

      ! CALCULATE DERIVATIVES - TENSOR
      CALL PAR_F_PAR_F(PROPS, DEFGRD_N, DEFGRDV_N, DIR_N, DEFGRD, 
     + DEFGRDV, DIR, DELTAT, TEMFF)
      CALL PAR_G_PAR_F(PROPS, DEFGRD, DEFGRDV, DIR, DELTAT, TEMGF)
      CALL PAR_F_PAR_D(PROPS, DEFGRD_N, DEFGRDV_N, DIR_N, DEFGRD, 
     + DEFGRDV, DIR, DELTAT, TEMFD)
      CALL PAR_F_PAR_FV(PROPS, DEFGRD_N, DEFGRDV_N, DIR_N, DEFGRD, 
     + DEFGRDV, DIR, DELTAT, TEMFV)
      CALL PAR_G_PAR_D(PROPS, DEFGRD, DEFGRDV, DIR, DELTAT, TEMGD)
      CALL PAR_G_PAR_FV(PROPS, DEFGRDV_N, DEFGRD, DEFGRDV, DIR, 
     + DELTAT, TEMGV)
      CALL PAR_P_PAR_D(PROPS, DEFGRD, DEFGRDV, DIR, TEMPD)
      CALL PAR_P_PAR_FV(PROPS, DEFGRD, DEFGRDV, DIR, TEMPV)
      CALL PAR_P_PAR_F(PROPS, DEFGRD, DEFGRDV, DIR, TEMPF)

! CONVERT TENSORS TO MATRIX
      KFD = TEMFD
      CALL TENSOR2MATRIX12(TEMFF, KFF)
      CALL TENSOR2MATRIX12(TEMFV, KFV)
      CALL TENSOR2MATRIX21(TEMGD, KGD)
      CALL TENSOR2MATRIX22(TEMGF, KGF)
      CALL TENSOR2MATRIX22(TEMGV, KGV)
      CALL TENSOR2MATRIX21(TEMPD, KPD)
      CALL TENSOR2MATRIX22(TEMPF, KPF)
      CALL TENSOR2MATRIX22(TEMPV, KPV)

! ASSIGN VALUES
      KF(1:3,:) = KFF
      KF(4:12,:) = KGF
      KQ(1:3,1:3) = KFD
      KQ(1:3,4:12) = KFV
      KQ(4:12,1:3) = KGD
      KQ(4:12,4:12) = KGV
      CQ(1:9,1:3) = KPD
      CQ(1:9,4:12) = KPV
      CF = KPF

      CALL MATINVMD(KQ, 12, IKQ)
      RESOUT = CF - MATMUL(CQ,MATMUL(IKQ,KF))

      END SUBROUTINE

      SUBROUTINE TANGENT_SVARS(PROPS, DEFGRD_N, DEFGRDV_N, DIR_N, 
     + DEFGRD, DEFGRDV_ITER, DIR_ITER, DELTAT, KSVARS)
! TANGENT STIFFNESS OF STATE VARIABLES
      IMPLICIT NONE
      REAL*8 PROPS(12), DEFGRD_N(3,3), DEFGRDV_N(3,3), DIR_N(3), 
     + DEFGRD(3,3), DEFGRDV_ITER(3,3), DIR_ITER(3), DELTAT,KSVARS(12,12)
      REAL*8 TEMFD(3,3), TEMFV(3,3,3), TEMGD(3,3,3), TEMGV(3,3,3,3)
      REAL*8 KFD(3,3), KFV(3,9), KGD(9,3), KGV(9,9)

      CALL PAR_F_PAR_D(PROPS, DEFGRD_N, DEFGRDV_N, DIR_N, DEFGRD, 
     + DEFGRDV_ITER, DIR_ITER, DELTAT, TEMFD)
      CALL PAR_F_PAR_FV(PROPS, DEFGRD_N, DEFGRDV_N, DIR_N, DEFGRD, 
     + DEFGRDV_ITER, DIR_ITER, DELTAT, TEMFV)
      CALL PAR_G_PAR_D(PROPS, DEFGRD, DEFGRDV_ITER, DIR_ITER, 
     + DELTAT, TEMGD)
      CALL PAR_G_PAR_FV(PROPS, DEFGRDV_N, DEFGRD, DEFGRDV_ITER, 
     + DIR_ITER, DELTAT, TEMGV)

      KFD = TEMFD
      CALL TENSOR2MATRIX12(TEMFV, KFV)
      CALL TENSOR2MATRIX21(TEMGD, KGD)
      CALL TENSOR2MATRIX22(TEMGV, KGV)

      KSVARS(1:3,1:3) = KFD
      KSVARS(1:3,4:12) = KFV
      KSVARS(4:12,1:3) = KGD
      KSVARS(4:12,4:12) = KGV
      RETURN
      END SUBROUTINE

      SUBROUTINE CAL_DINT(PROPS, DEFGRD_N, DEFGRDV_N, DIR_N, DEFGRD,
     +  DEFGRDV, DIR, DELTAT, DINT)
! CALCULATE VISCOS DISSIPATION AT INTEGRATION POINT
      IMPLICIT NONE
      REAL*8 PROPS(12), DEFGRD_N(3,3), DEFGRDV_N(3,3), DIR_N(3)
      REAL*8 DEFGRD(3,3), DEFGRDV(3,3), DIR(3), DELTAT, DINT
      REAL*8 FV_DOT(3,3),DIR_DOT(3), FV_INV(3,3), LV(3,3)
      REAL*8 F_DOT(3,3), F_INV(3,3), LMTX(3,3), WMTX(3,3)
      REAL*8 WD(3), DIR_JDOT(3), SIGTEM(3,3), ETA_D, ETA_N
      REAL*8 NORM_LV, NORM_DIR_JDOT, TEMP1, TEMP2, JCB
      
! CALCULATE TIME DERIVATIVES
      FV_DOT(1,1) = (DEFGRDV(1,1) - DEFGRDV_N(1,1))/DELTAT
      FV_DOT(1,2) = (DEFGRDV(1,2) - DEFGRDV_N(1,2))/DELTAT
      FV_DOT(1,3) = (DEFGRDV(1,3) - DEFGRDV_N(1,3))/DELTAT
      FV_DOT(2,1) = (DEFGRDV(2,1) - DEFGRDV_N(2,1))/DELTAT
      FV_DOT(2,2) = (DEFGRDV(2,2) - DEFGRDV_N(2,2))/DELTAT
      FV_DOT(2,3) = (DEFGRDV(2,3) - DEFGRDV_N(2,3))/DELTAT
      FV_DOT(3,1) = (DEFGRDV(3,1) - DEFGRDV_N(3,1))/DELTAT
      FV_DOT(3,2) = (DEFGRDV(3,2) - DEFGRDV_N(3,2))/DELTAT
      FV_DOT(3,3) = (DEFGRDV(3,3) - DEFGRDV_N(3,3))/DELTAT
      
      CALL MATINV3D(DEFGRDV, FV_INV)
      LV = MATMUL(FV_DOT,FV_INV)
      
      DIR_DOT(1) = (DIR(1) - DIR_N(1))/DELTAT
      DIR_DOT(2) = (DIR(2) - DIR_N(2))/DELTAT
      DIR_DOT(3) = (DIR(3) - DIR_N(3))/DELTAT
      
      F_DOT(1,1) = (DEFGRD(1,1) - DEFGRD_N(1,1))/DELTAT
      F_DOT(1,2) = (DEFGRD(1,2) - DEFGRD_N(1,2))/DELTAT
      F_DOT(1,3) = (DEFGRD(1,3) - DEFGRD_N(1,3))/DELTAT
      F_DOT(2,1) = (DEFGRD(2,1) - DEFGRD_N(2,1))/DELTAT
      F_DOT(2,2) = (DEFGRD(2,2) - DEFGRD_N(2,2))/DELTAT
      F_DOT(2,3) = (DEFGRD(2,3) - DEFGRD_N(2,3))/DELTAT
      F_DOT(3,1) = (DEFGRD(3,1) - DEFGRD_N(3,1))/DELTAT
      F_DOT(3,2) = (DEFGRD(3,2) - DEFGRD_N(3,2))/DELTAT
      F_DOT(3,3) = (DEFGRD(3,3) - DEFGRD_N(3,3))/DELTAT
      
      CALL MATINV3D(DEFGRD, F_INV)
      LMTX = MATMUL(F_DOT,F_INV)
      WMTX = 0.5*(LMTX-TRANSPOSE(LMTX))
      
      CALL MATVEC(WMTX, DIR, 3, 3, WD)
      DIR_JDOT = DIR_DOT - WD
      
! OBTAIN VISCO COEFFICIENTS
      CALL SIGMA(PROPS, DEFGRD, DEFGRDV, DIR, SIGTEM)
      CALL FETAD(PROPS, SIGTEM, ETA_D)
      ETA_N = PROPS(6)
      
! CALCULATE DINT
      CALL DET(DEFGRD, JCB)
      CALL DDOT(LV, LV, NORM_LV)
      NORM_DIR_JDOT = DOT_PRODUCT(DIR_JDOT,DIR_JDOT)
      DINT = ETA_N*NORM_LV + JCB*ETA_D*NORM_DIR_JDOT
      
      RETURN
      END SUBROUTINE
      
      SUBROUTINE CAL_DIR_DISSIPATION(PROPS, DEFGRD_N, DEFGRDV_N, DIR_N, 
     +           DEFGRD, DEFGRDV, DIR, DELTAT, DINT)
! DISSIPATION FROM DIRECTOR ROTATION
      IMPLICIT NONE
      REAL*8 PROPS(12), DEFGRD_N(3,3), DEFGRDV_N(3,3), DIR_N(3)
      REAL*8 DEFGRD(3,3), DEFGRDV(3,3), DIR(3), DELTAT, DINT
      REAL*8 DIR_DOT(3), F_DOT(3,3), F_INV(3,3), LMTX(3,3), WMTX(3,3)
      REAL*8 WD(3), DIR_JDOT(3), SIGTEM(3,3), ETA_D, NORM_DIR_JDOT

! CALCULATE TIME DERIVATIVES    
      DIR_DOT(1) = (DIR(1) - DIR_N(1))/DELTAT
      DIR_DOT(2) = (DIR(2) - DIR_N(2))/DELTAT
      DIR_DOT(3) = (DIR(3) - DIR_N(3))/DELTAT
      
      F_DOT(1,1) = (DEFGRD(1,1) - DEFGRD_N(1,1))/DELTAT
      F_DOT(1,2) = (DEFGRD(1,2) - DEFGRD_N(1,2))/DELTAT
      F_DOT(1,3) = (DEFGRD(1,3) - DEFGRD_N(1,3))/DELTAT
      F_DOT(2,1) = (DEFGRD(2,1) - DEFGRD_N(2,1))/DELTAT
      F_DOT(2,2) = (DEFGRD(2,2) - DEFGRD_N(2,2))/DELTAT
      F_DOT(2,3) = (DEFGRD(2,3) - DEFGRD_N(2,3))/DELTAT
      F_DOT(3,1) = (DEFGRD(3,1) - DEFGRD_N(3,1))/DELTAT
      F_DOT(3,2) = (DEFGRD(3,2) - DEFGRD_N(3,2))/DELTAT
      F_DOT(3,3) = (DEFGRD(3,3) - DEFGRD_N(3,3))/DELTAT
      
      CALL MATINV3D(DEFGRD, F_INV)
      LMTX = MATMUL(F_DOT,F_INV)
      WMTX = 0.5*(LMTX-TRANSPOSE(LMTX))
      
      CALL MATVEC(WMTX, DIR, 3, 3, WD)
      DIR_JDOT = DIR_DOT - WD
      
! OBTAIN VISCO COEFFICIENTS
      CALL SIGMA(PROPS, DEFGRD, DEFGRDV, DIR, SIGTEM)
      CALL FETAD(PROPS, SIGTEM, ETA_D)
      
! CALCULATE DINT
      NORM_DIR_JDOT = DOT_PRODUCT(DIR_JDOT,DIR_JDOT)
      DINT = ETA_D*NORM_DIR_JDOT
      
      RETURN
      END SUBROUTINE
      
      SUBROUTINE FREE_ENERGY(PROPS, DEFGRD, DEFGRDV, DIR, PSI)
! CALCULATE FREE ENERGY DENSITY
      IMPLICIT NONE
      REAL*8 PROPS(12), DEFGRD(3,3), DEFGRDV(3,3), DIR(3), PSI
      REAL*8 MUEQ, MUNEQ, LOCKLIM, BULKPENALTY, DIRPENALTY
      REAL*8 ELAI, ELAIE, DEFGRDE(3,3), JCB, JECB, DIR_SQUARE
      REAL*8 PSI_EQ, PSI_NEQ, PSI_B, PSI_D
      
! GET MATERIAL PROPERTIES
      MUEQ = PROPS(3)
      MUNEQ = PROPS(4)
      LOCKLIM = PROPS(2)
      BULKPENALTY = PROPS(11)
      DIRPENALTY = PROPS(12)

! PREPARE MIDDLE VARIABLES
      CALL CAL_ELAI(PROPS, DEFGRD, DEFGRDV, DIR, ELAI, ELAIE)
      CALL CAL_DEFGRDE(DEFGRD, DEFGRDV, DEFGRDE)
      CALL DET(DEFGRD, JCB)
      CALL DET(DEFGRDE, JECB)
      DIR_SQUARE = DOT_PRODUCT(DIR, DIR)
      
! CALCULATE ENERGY
      PSI_EQ = - MUEQ/2.*LOCKLIM*LOG(1.-(ELAI-3.)/LOCKLIM) 
     +        - MUEQ*LOG(JCB)
      PSI_NEQ = - MUNEQ/2.*LOCKLIM*LOG(1.-(ELAIE-3.)/LOCKLIM) 
     +        - MUNEQ*LOG(JECB)
      PSI_B = BULKPENALTY/2.*(JCB-1.)**2
      PSI_D = DIRPENALTY/4.*(DIR_SQUARE-1.)**2
      PSI = PSI_EQ + PSI_NEQ + PSI_B + PSI_D
      
      RETURN
      END SUBROUTINE
      
      SUBROUTINE CAL_PSI_DOT(PROPS, DEFGRD_N, DEFGRDV_N, DIR_N, DEFGRD,
     +             DEFGRDV, DIR, DELTAT, PSI_DOT)
! CALCULATE RATE OF ENERGY (PSI)
      IMPLICIT NONE
      REAL*8 PROPS(12), DEFGRD_N(3,3), DEFGRDV_N(3,3), DIR_N(3)
      REAL*8 DEFGRD(3,3), DEFGRDV(3,3), DIR(3), DELTAT, PSI_DOT
      REAL*8 PSI_N, PSI
      
      CALL FREE_ENERGY(PROPS, DEFGRD_N, DEFGRDV_N, DIR_N, PSI_N)
      CALL FREE_ENERGY(PROPS, DEFGRD, DEFGRDV, DIR, PSI)
      
      PSI_DOT = (PSI - PSI_N) / DELTAT
      
      RETURN
      END SUBROUTINE
      
      SUBROUTINE CAL_PSI_DOT2(PROPS, DEFGRD_N, DEFGRDV_N, DIR_N, DEFGRD,
     +             DEFGRDV, DIR, DELTAT, PSI_DOT)
! CALCULATE RATE OF ENERGY (PSI) BY DEFINITION
      IMPLICIT NONE
      REAL*8 PROPS(12), DEFGRD_N(3,3), DEFGRDV_N(3,3), DIR_N(3), DELTAT
      REAL*8 DEFGRD(3,3), DEFGRDV(3,3), DIR(3), PSI_DOT, DEFGRDE_N(3,3)
      REAL*8 DEFGRDE(3,3), F_DOT(3,3), FV_DOT(3,3), DIR_DOT(3)
      REAL*8 INF(3,3), INEF(3,3), INEFV(3,3), IND(3), INED(3)
      REAL*8 JF(3,3), JEF(3,3), JEFV(3,3), JCB, JECB, ELAI, ELAIE
      REAL*8 MUEQ, MUNEQ, LOCKLIM, BULKPENALTY, DIRPENALTY
      REAL*8 PSIEQ_F(3,3), PSINEQ_F(3,3), PSIB_F(3,3)
      REAL*8 PSINEQ_FV(3,3), PSIEQ_D(3), PSINEQ_D(3), PSID_D(3)
      REAL*8 RATE_F, RATE_FV, RATE_D
      REAL*8 TEM33(3,3), TEM3(3)
      
! CALCULATE F_DOT, FV_DOT AND D_DOT
      FV_DOT(1,1) = (DEFGRDV(1,1) - DEFGRDV_N(1,1))/DELTAT
      FV_DOT(1,2) = (DEFGRDV(1,2) - DEFGRDV_N(1,2))/DELTAT
      FV_DOT(1,3) = (DEFGRDV(1,3) - DEFGRDV_N(1,3))/DELTAT
      FV_DOT(2,1) = (DEFGRDV(2,1) - DEFGRDV_N(2,1))/DELTAT
      FV_DOT(2,2) = (DEFGRDV(2,2) - DEFGRDV_N(2,2))/DELTAT
      FV_DOT(2,3) = (DEFGRDV(2,3) - DEFGRDV_N(2,3))/DELTAT
      FV_DOT(3,1) = (DEFGRDV(3,1) - DEFGRDV_N(3,1))/DELTAT
      FV_DOT(3,2) = (DEFGRDV(3,2) - DEFGRDV_N(3,2))/DELTAT
      FV_DOT(3,3) = (DEFGRDV(3,3) - DEFGRDV_N(3,3))/DELTAT
      
      DIR_DOT(1) = (DIR(1) - DIR_N(1))/DELTAT
      DIR_DOT(2) = (DIR(2) - DIR_N(2))/DELTAT
      DIR_DOT(3) = (DIR(3) - DIR_N(3))/DELTAT
      
      F_DOT(1,1) = (DEFGRD(1,1) - DEFGRD_N(1,1))/DELTAT
      F_DOT(1,2) = (DEFGRD(1,2) - DEFGRD_N(1,2))/DELTAT
      F_DOT(1,3) = (DEFGRD(1,3) - DEFGRD_N(1,3))/DELTAT
      F_DOT(2,1) = (DEFGRD(2,1) - DEFGRD_N(2,1))/DELTAT
      F_DOT(2,2) = (DEFGRD(2,2) - DEFGRD_N(2,2))/DELTAT
      F_DOT(2,3) = (DEFGRD(2,3) - DEFGRD_N(2,3))/DELTAT
      F_DOT(3,1) = (DEFGRD(3,1) - DEFGRD_N(3,1))/DELTAT
      F_DOT(3,2) = (DEFGRD(3,2) - DEFGRD_N(3,2))/DELTAT
      F_DOT(3,3) = (DEFGRD(3,3) - DEFGRD_N(3,3))/DELTAT

! CALCULATE MIDDLE VARIABLES
      CALL CAL_DEFGRDE(DEFGRD, DEFGRDV, DEFGRDE)
      CALL PAR_IN_PAR_F(PROPS, DEFGRD, DIR, INF)
      CALL PAR_INE_PAR_F(PROPS, DEFGRD, DEFGRDV, DIR, INEF)
      CALL PAR_INE_PAR_FV(PROPS, DEFGRD, DEFGRDV, DIR, INEFV)
      CALL PAR_IN_PAR_D(PROPS, DEFGRD, DIR, IND)
      CALL PAR_INE_PAR_D(PROPS, DEFGRD, DEFGRDV, DIR, INED)
      CALL PAR_JCB_PAR_F(DEFGRD, JF)
      CALL PAR_JECB_PAR_F(DEFGRD, DEFGRDV, JEF)
      CALL PAR_JECB_PAR_FV(DEFGRD, DEFGRDV, JEFV)
      CALL DET(DEFGRD, JCB)
      CALL DET(DEFGRDE, JECB)
      CALL CAL_ELAI(PROPS, DEFGRD, DEFGRDV, DIR, ELAI, ELAIE)
      
! GET MATERIAL PROPERTIES
      MUEQ = PROPS(3)
      MUNEQ = PROPS(4)
      LOCKLIM = PROPS(2)
      BULKPENALTY = PROPS(11)
      DIRPENALTY =  PROPS(12)
      
! CALCULATE DERIVATIVES OF PSI
! RESPECT TO F
      PSIEQ_F = MUEQ/2.*LOCKLIM/(LOCKLIM - (ELAI-3.))*INF
     +                   -MUEQ/JCB*JF
      PSINEQ_F = MUNEQ/2.*LOCKLIM/(LOCKLIM - (ELAIE-3.))*INEF
     +                   -MUNEQ/JECB*JEF
      PSIB_F = BULKPENALTY*(JCB-1.)*JF
      
! RESPECT TO FV
      PSINEQ_FV = MUNEQ/2.*LOCKLIM/(LOCKLIM - (ELAIE-3.))*INEFV
     +                   -MUNEQ/JECB*JEFV
      
! RESPECT TO D
      PSIEQ_D =  MUEQ/2.*LOCKLIM/(LOCKLIM - (ELAI-3.))*IND
      PSINEQ_D = MUNEQ/2.*LOCKLIM/(LOCKLIM - (ELAIE-3.))*INED
      PSID_D = DIRPENALTY*(DOT_PRODUCT(DIR,DIR)-1)*DIR

! CALCULATE CONTRIBUTION TO TOTAL ENERGY RATE
      TEM33 = PSIEQ_F + PSINEQ_F + PSIB_F
      CALL DDOT(TEM33,F_DOT, RATE_F)
      CALL DDOT(PSINEQ_FV, FV_DOT, RATE_FV)
      TEM3 = PSIEQ_D + PSINEQ_D + PSID_D
      RATE_D = DOT_PRODUCT(TEM3,DIR_DOT)
      PSI_DOT = RATE_F + RATE_FV + RATE_D
      
      RETURN
      END SUBROUTINE
      
      SUBROUTINE CAL_PSI_DOT3(PROPS, DEFGRD_N, DEFGRDV_N, DIR_N, DEFGRD,
     +             DEFGRDV, DIR, DELTAT, PSI_DOT)
! CALCULATE RATE OF ENERGY (PSI) BY DEFINITION
      IMPLICIT NONE
      REAL*8 PROPS(12), DEFGRD_N(3,3), DEFGRDV_N(3,3), DIR_N(3), DELTAT
      REAL*8 DEFGRD(3,3), DEFGRDV(3,3), DIR(3), PSI_DOT, DEFGRDE_N(3,3)
      REAL*8 DEFGRDE(3,3), F_DOT(3,3), FE_DOT(3,3), DIR_DOT(3)
      REAL*8 INF(3,3), INEFE(3,3), IND(3), INED(3)
      REAL*8 JF(3,3), JEFE(3,3), JCB, JECB, ELAI, ELAIE
      REAL*8 MUEQ, MUNEQ, LOCKLIM, BULKPENALTY, DIRPENALTY
      REAL*8 PSIEQ_F(3,3), PSINEQ_FE(3,3), PSIB_F(3,3)
      REAL*8 PSIEQ_D(3), PSINEQ_D(3), PSID_D(3)
      REAL*8 RATE_F, RATE_FE, RATE_D
      REAL*8 TEM33(3,3), TEM3(3)
      
! CALCULATE F_DOT, FV_DOT AND D_DOT
      CALL CAL_DEFGRDE(DEFGRD, DEFGRDV, DEFGRDE)
      CALL CAL_DEFGRDE(DEFGRD_N, DEFGRDV_N, DEFGRDE_N)
      FE_DOT(1,1) = (DEFGRDE(1,1) - DEFGRDE_N(1,1))/DELTAT
      FE_DOT(1,2) = (DEFGRDE(1,2) - DEFGRDE_N(1,2))/DELTAT
      FE_DOT(1,3) = (DEFGRDE(1,3) - DEFGRDE_N(1,3))/DELTAT
      FE_DOT(2,1) = (DEFGRDE(2,1) - DEFGRDE_N(2,1))/DELTAT
      FE_DOT(2,2) = (DEFGRDE(2,2) - DEFGRDE_N(2,2))/DELTAT
      FE_DOT(2,3) = (DEFGRDE(2,3) - DEFGRDE_N(2,3))/DELTAT
      FE_DOT(3,1) = (DEFGRDE(3,1) - DEFGRDE_N(3,1))/DELTAT
      FE_DOT(3,2) = (DEFGRDE(3,2) - DEFGRDE_N(3,2))/DELTAT
      FE_DOT(3,3) = (DEFGRDE(3,3) - DEFGRDE_N(3,3))/DELTAT
      
      DIR_DOT(1) = (DIR(1) - DIR_N(1))/DELTAT
      DIR_DOT(2) = (DIR(2) - DIR_N(2))/DELTAT
      DIR_DOT(3) = (DIR(3) - DIR_N(3))/DELTAT
      
      F_DOT(1,1) = (DEFGRD(1,1) - DEFGRD_N(1,1))/DELTAT
      F_DOT(1,2) = (DEFGRD(1,2) - DEFGRD_N(1,2))/DELTAT
      F_DOT(1,3) = (DEFGRD(1,3) - DEFGRD_N(1,3))/DELTAT
      F_DOT(2,1) = (DEFGRD(2,1) - DEFGRD_N(2,1))/DELTAT
      F_DOT(2,2) = (DEFGRD(2,2) - DEFGRD_N(2,2))/DELTAT
      F_DOT(2,3) = (DEFGRD(2,3) - DEFGRD_N(2,3))/DELTAT
      F_DOT(3,1) = (DEFGRD(3,1) - DEFGRD_N(3,1))/DELTAT
      F_DOT(3,2) = (DEFGRD(3,2) - DEFGRD_N(3,2))/DELTAT
      F_DOT(3,3) = (DEFGRD(3,3) - DEFGRD_N(3,3))/DELTAT

! CALCULATE MIDDLE VARIABLES
      CALL PAR_IN_PAR_F(PROPS, DEFGRD, DIR, INF)
      CALL PAR_IN_PAR_F(PROPS, DEFGRDE, DIR, INEFE)
      CALL PAR_IN_PAR_D(PROPS, DEFGRD, DIR, IND)
      CALL PAR_INE_PAR_D(PROPS, DEFGRD, DEFGRDV, DIR, INED)
      CALL PAR_JCB_PAR_F(DEFGRD, JF)
      CALL PAR_JCB_PAR_F(DEFGRDE, JEFE)
      CALL DET(DEFGRD, JCB)
      CALL DET(DEFGRDE, JECB)
      CALL CAL_ELAI(PROPS, DEFGRD, DEFGRDV, DIR, ELAI, ELAIE)
      
! GET MATERIAL PROPERTIES
      MUEQ = PROPS(3)
      MUNEQ = PROPS(4)
      LOCKLIM = PROPS(2)
      BULKPENALTY = PROPS(11)
      DIRPENALTY =  PROPS(12)
      
! CALCULATE DERIVATIVES OF PSI
! RESPECT TO F
      PSIEQ_F = MUEQ/2.*LOCKLIM/(LOCKLIM - (ELAI-3.))*INF
     +                   -MUEQ/JCB*JF
      PSIB_F = BULKPENALTY*(JCB-1.)*JF
      
! RESPECT TO FE
      PSINEQ_FE = MUNEQ/2.*LOCKLIM/(LOCKLIM - (ELAIE-3.))*INEFE
     +                   -MUNEQ/JECB*JEFE
      
! RESPECT TO D
      PSIEQ_D =  MUEQ/2.*LOCKLIM/(LOCKLIM - (ELAI-3.))*IND
      PSINEQ_D = MUNEQ/2.*LOCKLIM/(LOCKLIM - (ELAIE-3.))*INED
      PSID_D = DIRPENALTY*(DOT_PRODUCT(DIR,DIR)-1)*DIR

! CALCULATE CONTRIBUTION TO TOTAL ENERGY RATE
      TEM33 = PSIEQ_F + PSIB_F
      CALL DDOT(TEM33,F_DOT, RATE_F)
      CALL DDOT(PSINEQ_FE, FE_DOT, RATE_FE)
      TEM3 = PSIEQ_D + PSINEQ_D + PSID_D
      RATE_D = DOT_PRODUCT(TEM3,DIR_DOT)
      PSI_DOT = RATE_F + RATE_FE + RATE_D
      
      RETURN
      END SUBROUTINE
      
      SUBROUTINE PAR_JCB_PAR_F(DEFGRD, RESOUT)
! CALCULATE DJ/DF
      IMPLICIT NONE
      REAL*8 JCB, DEFGRD(3,3), RESOUT(3,3), F_INV(3,3)
      INTEGER J, B
      
      CALL MATINV3D(DEFGRD, F_INV)
      CALL DET(DEFGRD, JCB)
      RESOUT = 0.
      DO J = 1,3
          DO B = 1,3
              RESOUT(J,B) = JCB*F_INV(B,J)
          END DO
      END DO

      RETURN
      END SUBROUTINE 

      SUBROUTINE PAR_JECB_PAR_F(DEFGRD, DEFGRDV, RESOUT)
! CALCULATE DJE/DF
      IMPLICIT NONE
      REAL*8 DEFGRD(3,3), DEFGRDV(3,3), DEFGRDE(3,3)
      REAL*8 JEFE(3,3), FEF(3,3,3,3), RESOUT(3,3)
      INTEGER I, ALPHA, J, B
      
      CALL CAL_DEFGRDE(DEFGRD, DEFGRDV, DEFGRDE)
      CALL PAR_JCB_PAR_F(DEFGRDE, JEFE)
      CALL PAR_FE_PAR_F(DEFGRDV, FEF)
      
      RESOUT = 0.
      DO J = 1,3
      DO B = 1,3
      DO I = 1,3
      DO ALPHA = 1,3
          RESOUT(J,B) = RESOUT(J,B) + JEFE(I,ALPHA)*FEF(I,ALPHA,J,B)
      END DO
      END DO
      END DO
      END DO
      
      RETURN
      END SUBROUTINE

      SUBROUTINE PAR_JECB_PAR_FV(DEFGRD, DEFGRDV, RESOUT)
! CALCULATE DJE/DF
      IMPLICIT NONE
      REAL*8 DEFGRD(3,3), DEFGRDV(3,3), DEFGRDE(3,3)
      REAL*8 JEFE(3,3), FEFV(3,3,3,3), RESOUT(3,3)
      INTEGER I, BETA, ALPHA, A
      
      CALL CAL_DEFGRDE(DEFGRD, DEFGRDV, DEFGRDE)
      CALL PAR_JCB_PAR_F(DEFGRDE, JEFE)
      CALL PAR_FE_PAR_FV(DEFGRD, DEFGRDV, FEFV)
      
      RESOUT = 0.
      DO I = 1,3
      DO BETA = 1,3
      DO ALPHA = 1,3
      DO A = 1,3
      RESOUT(ALPHA,A) = RESOUT(ALPHA,A) + 
     +     JEFE(I,BETA)*FEFV(I,BETA,ALPHA,A)
      END DO
      END DO
      END DO
      END DO
      
      RETURN
      END SUBROUTINE

      SUBROUTINE CAL_STRESS_POWER(PROPS, DEFGRD_N, DEFGRDV_N, DIR_N, 
     +             DEFGRD, DEFGRDV, DIR, DELTAT, SIGPOWER)
! CALCULATE STRESS PWOER AT INTEGRATION POINT
      IMPLICIT NONE
      REAL*8 PROPS(12), DEFGRD_N(3,3), DEFGRDV_N(3,3), DIR_N(3)
      REAL*8 DEFGRD(3,3), DEFGRDV(3,3), DIR(3), DELTAT, SIGPOWER
      REAL*8 F_DOT(3,3), PKSTRESS(3,3), JCB
      
! CALCULATE F_DOT     
      F_DOT(1,1) = (DEFGRD(1,1) - DEFGRD_N(1,1))/DELTAT
      F_DOT(1,2) = (DEFGRD(1,2) - DEFGRD_N(1,2))/DELTAT
      F_DOT(1,3) = (DEFGRD(1,3) - DEFGRD_N(1,3))/DELTAT
      F_DOT(2,1) = (DEFGRD(2,1) - DEFGRD_N(2,1))/DELTAT
      F_DOT(2,2) = (DEFGRD(2,2) - DEFGRD_N(2,2))/DELTAT
      F_DOT(2,3) = (DEFGRD(2,3) - DEFGRD_N(2,3))/DELTAT
      F_DOT(3,1) = (DEFGRD(3,1) - DEFGRD_N(3,1))/DELTAT
      F_DOT(3,2) = (DEFGRD(3,2) - DEFGRD_N(3,2))/DELTAT
      F_DOT(3,3) = (DEFGRD(3,3) - DEFGRD_N(3,3))/DELTAT
      
! CALCULATE STRESS
      CALL PK1(PROPS, DEFGRD, DEFGRDV, DIR, PKSTRESS)
      CALL DDOT(PKSTRESS, F_DOT, SIGPOWER)
      CALL DET(DEFGRD, JCB)
      
      SIGPOWER = SIGPOWER
      
      RETURN
      END SUBROUTINE 
